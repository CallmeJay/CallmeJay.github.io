<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack前端工程化入门]]></title>
    <url>%2F2019%2F08%2F06%2Fwebpack%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前端工程化是什么？ 这是个很大的概念，但是在我们的日常开发中又很常见。当我们对一个工程进行设计并把它拆分成各个组件和模块时，我们是在做工程化；当我们用 Webpack 构建项目，配置好各个环境的打包配置时，我们是在做工程化；当我们为项目添加了 ESLint，并在每次提交之前自动检查代码质量时，我们是在做工程化。 如果要用一句话来概括，在我的理解中前端工程化是把前端开发工作带入到更加系统和规范体系的一系列过程。这个过程会包括源代码的预编译、模块处理、代码压缩等构建方面的工作。工程化会尽可能保证开发者的开发体验更加友好，保证源代码的质量以及依赖的完整性。工程化也会尽可能高效地将构建完成后的代码送达给客户端，来追求更加良好的用户体验。所有这些都属于工程化。 走向正轨的第一步——模块化一个设计良好的系统应该是模块化的。一个最简单的原因，在一个模块化的系统中，当外界的需求亦或环境变化的时候，开发者可以更快地将问题定位到相应的模块，而不必面对纠缠在一起的逻辑不知如何下手。模块化可以使系统具备更强的可维护性。 被封装良好的模块应该具备特定且单一的功能，对外界只提供接口，而将具体实现封装在内部。Webpack 中有一个核心的理念——”一切皆模块”，即 HTML、JavaScript、CSS、图片等等都是模块，在后面的文章中会展开讲。 另外在将代码提供给客户端之前，开发者可以通过 Browserify、Webpack 这些工具将工程代码进行打包，把所有依赖模块打包为单一的 JavaScript 文件。这样一来，对于开发者而言开发体验更加友好，因为开发中每次需要关注的仅仅是单个模块，而不是堆放在一起的上千行 JavaScript 文件；而对于客户端来说则只用接受单一的打包产物，解决了文件数量过多导致 HTTP 请求耗时长的问题。解决模块之间的依赖，并根据依赖树进行打包，是工程化解决的最基本的问题之一。 什么是模块在软件工程设计中，我们通常将具有特定功能的代码封装为模块。比如在一个 Web 应用里，可能会有专门负责处理网络请求的模块、专门负责日期处理的模块、专门负责渲染的模块等等，每个模块各自发挥着不同的作用，都是系统不可缺少的一部分。 具体到代码层面，模块则是一个较为笼统和宽泛的概念，实现的形式并不一样。在一些情况下，一个文件可以包含多个模块，也可以与模块一一对应。比如在工程中也许会有一个 error.js 专门用于错误处理，或者通过 util.js 来放各种工具函数，由每个文件负责一个单一的功能。 为什么要使用模块模块化的设计可以为系统带来很多好处，在我看来最重要的有以下几个： 1.作用域封装：在 JavaScript 中代码执行的顶层作用域即是全局作用域，这意味着变量和函数定义很容易冲突。而使用模块将代码封装起来，可保证内部实现不会暴露在全局作用域中，我们只需将模块的功能通过接口的方式暴露出去给其它模块调用即可，避免了污染全局命名空间的问题。 2.重用性：在工程中经常会出现重复的部分，比如一个 Web 应用中各个页面共同的 header、footer，最原始的开发方式是将同样的代码复制粘贴到各个地方。这种做法的缺点是当这些共同的部分发生改变时，我们需要逐一改动每个地方的代码。 而如果把实现一类功能的代码封装为模块之后，就可以提供给各个调用者。比如说应用中有一个 Dialog 组件，可以把它的结构和样式封装起来，在不同的页面中调用它。假如 Dialog 的样式需要调整，那么只要调整该模块那么相当于此修改对所有页面都生效。 3.解除耦合：试想一下如果有一个几千行代码的文件在你的工程里，内部实现了各种各样的功能并且互相调用，这样的代码调试起来有多痛苦。将系统分解为模块的一个很重要意义就是解除各部分之间的耦合。当系统的某个部分需要发生改变的时候，通过模块我们可以快速定位问题。由于模块把功能的具体实现封装在了内部，只要模块间的接口不变，模块内部的变化对于外面的其它部分并没有感知。因此通过模块化可以提升系统的可维护性。 4.按需加载：如果没有模块，所有的代码将被放在一个大文件里面统统塞给用户。当页面不断地增加功能，不断地添加代码，最终的文件只会越来越大，而页面也打开地越来越慢，对于用户来说非常不友好。使用模块化来拆分逻辑可以使页面需要的资源最先被加载，而后续的模块在恰当的时机再进行异步加载，从而让页面加载速度更快，用户也得到更好的体验。 CommonJS 与 Node.js 模块系统CommonJS 是于 2009 年提出的 JavaScript 规范，它最开始是为了定义服务端标准，而非用于浏览器环境。之后 Node.js 采用并实现了它的部分规范，在模块系统上进行了一些调整。一般来说，我们不会严格区分 CommonJS 与 Node.js 的模块标准，详述两种标准的区别超出了本文的范围，在下文中我会直接使用 CommonJS 来进行表述。 Browserify 的出现带来了浏览器环境模块的变革。它是一个运行在 Node 环境下的模块打包工具，可以把模块按照 Node.js 的模块规则合并为浏览器支持的形式，这使得浏览器端的框架类库也可以按照 CommonJS 的形式编写。随着 Node.js 以及 npm 流行，近两年来对于开发者来说遵循 CommonJS 标准来编写和使用模块已经成为了一个基本通识。 ES6 ModuleES6 Module 是目前比较推荐开发者使用的模块标准。之所以在过去我们有各种不同的模块化标准是因为 JavaScript 这门语言本身不具备模块化的特性，而现在 ES6 中已经具备了。ES6 Module 的模块语法和 CommonJS 很像，它通过 import 和 export 来进行模块的导入和导出。 12345import math from './math';export function sum(a, b) &#123; return a + b;&#125; 在 ES6 Module 中也是每个文件作为一个模块。和 CommonJS 不同的是，ES6 Module 的模块的依赖是静态的，或者说是在编译时确定的，而不是运行时确定的。 举个例子，我们可以在 CommonJS 中的 if 语句中 require 模块，根据代码运行时 if 的判断条件决定是否要引入该模块。 1234// 根据运行时条件确定是否引入if(Date.now() &gt; new Date('2019-01-01')) &#123; require('./my_module');&#125; 而在 ES6 Module 中则不允许这样做，import 必须在代码的顶层作用域，这意味着你不能把它放在 if 等代码块中。ES6 Module 这样规定的原因在于可以使编译器在编译阶段就可以获取到整个依赖树，从而进行代码静态分析层面的优化，比如检测出哪些模块是从来没有被使用过的，然后从打包结果中优化掉等等。 动态加载模块有些场景下我们希望能够动态地去加载一些模块，在 CommonJS 中可以直接使用 require 实现。 12345if(condition) &#123; require('moduleA');&#125; else &#123; require('moduleB');&#125; 但是在 ES6 Module 中，由于上面我们提到的 import 是在编译时被处理而非运行时，因此无法实现动态加载的特性。 123456789// 报错if(condition) &#123; require('moduleA');&#125;// 报错var foo = 'foo';var bar = 'bar';import foobar from (foo + bar); 为了解决这个问题，tc39 提出了一个 import() 函数提案。它可以接受一个参数，指定所加载的模块，并且返回一个 Promise 对象。 1234567var foo = 'foo';var bar = 'bar';import(foo + bar).then(module =&gt; &#123; console.log('foobar loaded:', module);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 目前 Webpack 从 2.0.0 版本开始已经支持该动态加载形式，在后面的文章中会更加详细地进行介绍。]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas初识]]></title>
    <url>%2F2019%2F07%2F11%2Fcanvas%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是CanvasCanvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制 1&lt;canvas id="canvas" width="300" height="200"&gt;&lt;/canvas&gt; 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas： 1234567var canvas = document.getElementById('canvas')if (canvas.getContext) &#123; console.log('你的浏览器支持Canvas!')&#125; else &#123; console.log('你的浏览器不支持Canvas!')&#125;// Internet Explorer 8 以及更早的版本不支持 &lt;canvas&gt; 元素 绘制2D图形，使用getContext(&#39;2d&#39;)方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 1const ctx = canvas.getContext('2d') 绘制线段1234567891011ctx.strokeStyle = 'red' // 描绘色ctx.lineWidth = 2 // 线条宽度ctx.moveTo(x0,y0)ctx.lineTo(x1,y1)// ...ctx.stroke() // 描绘路径ctx.fillStyle = '#fff' // 填充色ctx.fill() // 填充闭合区域ctx.beginPath() // 起始一条路径，或重置当前路径 之后的绘制不会对之前的线再绘制一次ctx.closePath() // 创建从当前点回到起始点的路径 闭合线路 绘制矩形12345678910111213141516171819202122// 绘制矩形ctx.rect(x,y,width,height) // 创建矩形ctx.stroke()ctx.fill()ctx.fillStyle = '#fff' // 填充色 默认黑色// 线性渐变色const my_gradient=ctx.createLinearGradient(x1,y1,x2,y2); // 起始点坐标x1,y1 终点坐标x2,y2 在这两点直线 间颜色渐变my_gradient.addColorStop(0, color1);my_gradient.addColorStop(1, color2);ctx.fillStyle=my_gradient;ctx.fillRect(x,y,width,height)// 绘制边框矩形ctx.strokeStyle = 'red' // 描绘色ctx.lineWidth = 2 // 线条宽度ctx.strokeRect(x,y,width,height)ctx.shadowBlur=20 // 设置阴影ctx.shadowColor="black"ctx.shadowOffsetX = value // 设置或返回阴影距形状的水平距离ctx.shadowOffsetY = value // 设置或返回阴影距形状的垂直距离 绘制圆形12345ctx.arc(x,y,r,sAngle,eAngle,counterclockwise); // 圆中心坐标x, y, 半径， 起始角度，结束角度，是否逆时针绘图//方法在画布上创建介于两个切线之间的弧/曲线。ctx.arcTo(x1,y1,x2,y2,r) // 两线相交点坐标x1,y1, 终点坐标x2,y2， 弧的半径 如果当前端点不是弧线起点，arcTo()方法还将添加一条当前端点到弧线起点的直线线段。ctx.stroke(); // 进行绘制 文字1234567// 设置或返回文本内容的当前字体属性ctx.font = 'bold 12px arial'ctx.textAlign = 'start|end|center|left|right' // 文本的对齐方式context.textBaseline="top|hanging|middle|bottom"; // 基线在文字水平方向的位置。ctx.fillText(text,x,y,maxWidth); // 在画布上绘制“被填充的”文本 文字 位置 x,y, 允许的最大文本宽度ctx.strokeText() // 在画布上绘制文本（无填充）同上ctx.measureText().width // 返回包含指定文本宽度的对象 宽度 图像1ctx.drawImage(img,x,y,width,height); // 图像源DOM 起始位置x,y 设置在画布上的图像宽高 在onload后执行 点击事件123456789101112131415canvas.addEventListener('click', (ev) =&gt; &#123; let x let y if (ev.layerX || ev.layerX === 0) &#123; x = ev.layerX y = ev.layerY &#125; else if (ev.offsetX || ev.offsetX === 0) &#123; // Opera x = ev.offsetX y = ev.offsetY &#125; return &#123; x, y &#125;&#125;)]]></content>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识总结-3]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-3%2F</url>
    <content type="text"><![CDATA[主要是针对面试中口述问题 说一下JS的Event Loop简单总结如下： JS是单线程的，其上面的所有任务都是在两个地方执行：执行栈和任务队列。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。 当执行栈的任务都执行完了（栈空），js会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。 这个过程是循环进行，所以称作Loop。 解释下js的闭包直接上MDN的解释：闭包是函数和声明该函数的词法环境的组合。 而在JavaScript中，函数是被作为一级对象使用的，它既可以本当作值返回，还可以当作参数传递。理解了：“Js中的函数运行在它们被定义的作用域，而不是它们被执行的作用域”（摘自《JavaScript语言精粹》） 这句话即可。 解释下Set和Map Set元素不允许重复 Map类似对象，但是它的键（key）可以是任意数据类型 Set的常用方法 12345678910111213141516171819202122// 实例化一个setconst set = new Set([1, 2, 3, 4]);// 遍历setfor (let item of set) &#123; console.log(item);&#125;// 添加元素，返回Set本身set.add(5).add(6);// Set大小console.log(set.size);// 检查元素存在console.log(set.has(0));// 删除指定元素，返回boollet success = set.delete(1);console.log(success);set.clear(); Map接口基本和Set一致。不同的是增加/获取新元素的API是：set/get(key, value) 12345678const map = new Map();// 以任意对象为 Key 值// 这里以 Date 对象为例let key = new Date();map.set(key, "today");console.log(map.get(key)); JS隐式转换及应用场景 -、*、/、% ：一律转换成数值后计算 +： 数字 + 字符串 = 字符串， 运算顺序是从左到右 数字 + 对象， 优先调用对象的valueOf -&gt; toString 数字 + boolean/null -&gt; 数字 数字 + undefined -&gt; NaN [1].toString() === ‘1’ {}.toString() === ‘[object object]’ NaN !== NaN 、+undefined 为 NaN null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN x == y 运算符隐式转换类型相同时，没有类型转换，主要注意NaN不与任何值相等，包括它自己，即NaN !== NaN。 类型不相同时 x,y 为null、undefined两者中一个,返回true x、y为Number和String类型时，则转换为Number类型比较。 有Boolean类型时，Boolean转化为Number类型比较。 一个Object类型，一个String或Number类型，将Object类型进行原始转换后，按上面流程进行原始值比较。 1234567891011[] == !&#123;&#125;//1、! 运算符优先级高于==，故先进行！运算。2、!&#123;&#125;运算结果为false，结果变成 [] == false比较。3、根据上面第7条，等式右边y = ToNumber(false) = 0。结果变成 [] == 0。4、按照上面第9条，比较变成ToPrimitive([]) == 0。 按照上面规则进行原始值转换，[]会先调用valueOf函数，返回this。 不是原始值，继续调用toString方法，x = [].toString() = &apos;&apos;。 故结果为 &apos;&apos; == 0比较。5、根据上面第5条，等式左边x = ToNumber(&apos;&apos;) = 0。 所以结果变为： 0 == 0，返回true，比较结束。 BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 哪些元素可以产生BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC的布局规则 内部的Box会在垂直方向，一个接一个地放置 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin-box的左边， 与包含块border-box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 调用栈调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁） 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。 当函数运行结束后，解释器将它从堆栈中移除，并在主代码列表中继续执行代码。 如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。 XSS攻击预防方式表单提交过程中，需要对提交的数据进行引号，尖括号，斜杠进行转义，防止标签或者是eval()的恶意代码注入。 123456789101112// 敏感符号转义function entities(s) &#123; let e = &#123; '"': '&amp;quot;', '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;' &#125; return s.replace(/["&lt;&gt;&amp;]/g, m =&gt; &#123; return e[m] &#125;)&#125; 关于let 是否变量提升12345let name = 'xiaoming';&#123; console.log(name) // Uncaught ReferenceError: name is not defined let name = 'limei'&#125; let变量如果不存在变量提升，console.log(name)就会输出xiaoming，结果却抛出了ReferenceError，那么这很好的说明了，let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。 变量的赋值可以分为三个阶段： 创建变量，在内存中开辟空间 初始化变量，将变量初始化为undefined 真正赋值 关于let、var和function： let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。function 的「创建」「初始化」和「赋值」都被提升了。 一句话概括RESTful就是用URL定位资源，用HTTP描述操作 REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 GET get方法在Rest中主要用于获取资源。规范的get方法处理器应该是幂等的，也就是说对一个资源不论发送多少次get请求都不会更改数据或造成破坏。 POST post方法在Rest请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息 PUT put方法在Rest中主要用于更新资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post. 因此为了使用put和delete方法, 需要以post发送请求，在表单中使用隐藏域发送真正的请求。put方法是幂等的，对同一URL资源做出的同一数据的任意次put请求其对数据的改变都是一致的。 DELETE Delete在Rest请求中主要用于删除资源，同put一样，也使用post发送请求。 click在ios上有300ms延迟，原因及如何解决原因： 应对 iPhone 这种小屏幕浏览桌面端站点的问题，实现之一最出名的当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。 (1)粗暴型，禁用缩放 1&lt;meta name="viewport" content="width=device-width, user-scalable=no"&gt; (2)利用FastClick，其原理是： 检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习react]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%AD%A6%E4%B9%A0react%2F</url>
    <content type="text"><![CDATA[组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。这是一个从无到有的过程，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。 virtual-domvirtual-dom也就是使用js的数据结构来表示dom元素的结构，因为不是真是的dom节点，也就称为虚拟DOM。它最大的特点是将页面进行抽象成JS对象形式，配合不同的工具使跨平台成为可能，可以根据不同的平台渲染出相应的真实“DOM”。除此之外，在页面进行更新的时候，可以将DOM元素的变动放在内存比较，再结合一些框架的机制，将多次的渲染合并成一次渲染更新。 挂载过程： 12345678910111213141516171819202122-&gt; constructor()-&gt; componentWillMount()-&gt; render()// 然后构造 DOM 元素插入页面-&gt; componentDidMount()// ...// 组件将要接收新的props执行 这个方法在初始化render时不会被调用。-&gt; componentWillReceiveProps(nextProps)// 判断组件是否应该重新渲染，默认是true 在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。-&gt; shouldComponentUpdate(nextProps, nextState)// 组件将要重新渲染 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 不能调用setState。造成死循环，导致程序崩溃。-&gt; componentWillUpdate(nextProps, nextState)// 组件重新渲染完成 不能调用setState。造成死循环，导致程序崩溃。-&gt; componentDidUpdate(prevProps, prevState, snapshot)// ...// 即将从页面中删除-&gt; componentWillUnmount()// 从页面中删除 组件的私有方法都用 _ 开头，所有事件监听的方法都用 handle 开头。把事件监听方法传给组件的时候，属性名用 on 开头。 组件的内容编写顺序如下 static 开头的类属性，如 defaultProps、propTypes。 构造函数，constructor。 getter/setter（还不了解的同学可以暂时忽略）。 组件生命周期。 _ 开头的私有方法。 事件监听方法，handle*。 render*开头的方法，有时候 render() 方法里面的内容会分开到不同函数里面进行，这些函数都以 render* 开头。 render() 方法。 什么是高阶组件（Higher-Order Component） 高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。新的组件使用传入的组件作为子组件。 作用：高阶组件的作用是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。新的组件和传入的组件通过 props 传递信息。 纯函数（Pure Function） 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用 除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，还有调用 window.reload 刷新浏览器，甚至是 console.log 往控制台打印数据也是副作用。 纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。 为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。 PureComponentReact.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新） 关注点 无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。 浅判断只会比较到两个对象的ownProperty是否符合 Object.is() 判等，不会递归地去深层比较。 至于复杂数据结构，用Object.key()获取下key，然后key和对应的value都是基础类型数据，就是算是简单数据结构，不然就是复杂 针对以上规则我们在项目开发种可以做出如下优化： 尽量将复杂类型数据（ArrayList）所关联的视图单独拆成PureComonent有助于提高渲染性能，比如表单、文本域和复杂列表在同一个 render() 中，表单域的输入字段改变会频繁地触发 setState() 从而导致 组件 重新 render()。而用于渲染复杂列表的数据其实并没有变化，但由于重新触发 render()，列表还是会重新渲染。 为什么要手动绑定this通过事件触发过程的分析，dispatchEvent调用了invokeGuardedCallback方法。 123456789function invokeGuardedCallback(name, func, a) &#123; try &#123; func(a); &#125; catch (x) &#123; if (caughtError === null) &#123; caughtError = x; &#125; &#125;&#125; 可见，回调函数是直接调用调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的this是undefined。这里可以使用实验性的属性初始化语法 ，也就是直接在组件声明箭头函数。箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此这样我们在React事件中获取到的就是组件本身了。 React事件和原生事件的执行顺序12345678910111213141516171819202122232425componentDidMount() &#123; this.parent.addEventListener('click', (e) =&gt; &#123; console.log('dom parent'); &#125;) document.addEventListener('click', (e) =&gt; &#123; console.log('document'); &#125;)&#125;parentClick = (e) =&gt; &#123; console.log('react parent');&#125;render() &#123; return ( &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; test &lt;/div&gt; )&#125;// dom parent// react parent// document 由上面的流程我们可以理解： react的所有事件都挂载在document中 当真实dom触发后冒泡到document后才会对react事件进行处理 所以原生的事件会先执行 然后执行react合成事件 最后执行真正在document上挂载的事件 React事件和原生事件可以混用吗react事件和原生事件最好不要混用。 原生事件中如果执行了stopPropagation方法，则会导致其他react事件失效。因为所有元素的事件将无法冒泡到document上。 由上面的执行机制不难得出，所有的react事件都将无法被注册。 基于路由的代码分割12345678910111213141516import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom';import React, &#123; Suspense, lazy &#125; from 'react';const Home = lazy(() =&gt; import('./routes/Home'));const About = lazy(() =&gt; import('./routes/About'));const App = () =&gt; ( &lt;Router&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt;); 用户定义的组件必须以大写字母开头以小写字母开头的元素代表一个 HTML 内置组件，比如 &lt;div&gt; 或者 &lt;span&gt; 会生成相应的字符串 &#39;div&#39; 或者 &#39;span&#39; 传递给 React.createElement（作为参数）。大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如 &lt;Foo /&gt; 会编译为 React.createElement(Foo)。 12345678910111213import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 正确！JSX 类型可以是大写字母开头的变量。 const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 字符串字面量12&lt;MyComponent message="hello world" /&gt;&lt;MyComponent message=&#123;'hello world'&#125; /&gt;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[必会的手写面试题]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%BF%85%E4%BC%9A%E7%9A%84%E6%89%8B%E5%86%99%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[函数柯里化 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 用途是实现多参函数。 12 实现深拷贝浅拷贝的方法有： Object.assign(),Array.from(),Array.slice(),Array.concat() 递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝 123456789101112131415161718192021222324252627282930313233//定义检测数据类型的功能函数function checkedType(target) &#123; return Object.prototype.toString.call(target).slice(8, -1)&#125;//实现深度克隆---对象/数组function clone(target) &#123; //判断拷贝的数据类型 //初始化变量result 成为最终克隆的数据 let result, targetType = checkedType(target) if (targetType === 'Object') &#123; result = &#123;&#125; &#125; else if (targetType === 'Array') &#123; result = [] &#125; else &#123; return target &#125; //遍历目标数据 for (let i in target) &#123; //获取遍历数据结构的每一项值。 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === 'Object' || checkedType(value) === 'Array') &#123; //对象/数组里嵌套了对象/数组 //继续遍历获取到value值 result[i] = clone(value) &#125; else &#123; //获取到value值是基本的数据类型或者是函数。 result[i] = value &#125; &#125; return result&#125;]]></content>
      <tags>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识总结-2]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-2%2F</url>
    <content type="text"><![CDATA[前端基础进阶系列 内存空间在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是堆(heap)，栈(stack)与队列(queue)。 栈数据结构有 后进先出(LIFO) 特点。堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。队列是一种先进先出（FIFO）的数据结构 基础数据类型大小固定，按值访问，存放在栈内存中。引用数据类型大小不固定，按引用访问，存放在堆内存中。 JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 执行上下文每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval（不建议使用，可忽略） 因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为 函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。 执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。 我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。 创建阶段在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。 代码执行阶段创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。 变量对象（Variable Object）变量对象的变化的创建，依次经历了下面过程： 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改（注意只是创建过程，不是执行过程）。 12345678910111213console.log(foo); // function foofunction foo() &#123; console.log('function foo') &#125;var foo = 20;// 首先将所有函数声明放入变量对象中function foo() &#123; console.log('function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // function foofoo = 20; 在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示 12345678910111213// 创建阶段testEC = &#123; VO: &#123;&#125;, //变量对象 scopeChain: &#123;&#125; // 作用域链&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt;, // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 全局上下文的变量对象以浏览器中为例，全局对象为window。全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 作用域 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 举个栗子 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object 作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 闭包闭包是一种特殊的对象。 它由两部分组成。执行上下文A,以及在该执行上下文中创建的函数B。 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。 因此，闭包的形成需要两个条件: 闭包是在函数被调用执行的时候才被确认创建的。 在函数内部创建新的函数; 新的函数在执行时，访问了函数的变量对象。 在大多数理解中，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 闭包造成内存泄露？ 内存泄露是指 你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。 闭包里面的变量明明就是我们需要的变量（lives），所以不是内存泄露 为何有人说是？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。 在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 this 指向首先我们需要得出一个非常重要一定要牢记于心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。除此之外 在函数执行过程中，this一旦被确定，就不可更改了。 在一个 函数上下文 中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; 'use strict'; console.log(this);&#125;fn(); // fn是调用者，独立调用 undifinedwindow.fn(); // fn是调用者，被window所拥有 Window 使用apply/call实现继承1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 总结一函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。 面向对象在ECMAScript-262中，对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。 也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。 假如我们有一个简单的对象如下： 1234567var person = &#123; name: 'TOM', age: '20', getName: function() &#123; return this.name &#125;&#125; 当我们想要访问他的name属性时，可以用如下两种方式访问。 1234person.name// 或者person['name'] 如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写： 123['name', 'age'].forEach(function(item) &#123; console.log(person[item]);&#125;) 这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。 工厂模式123456789101112131415161718var createPerson = function(name, age) &#123; // 声明一个中间对象，该对象就是工厂模式的模子 var o = new Object(); // 依次添加我们需要的属性与方法 o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;// 创建两个实例var perTom = createPerson('TOM', 20);var PerJake = createPerson('Jake', 22); 构造函数1234567891011121314151617181920212223242526272829303132333435363738// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;// 将构造函数以参数形式传入function New(func) &#123; // 声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; // 将实例的原型指向构造函数的原型 res.__proto__ = func.prototype; &#125; // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象 var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象 if ((typeof ret === "object" || typeof ret === "function") &amp;&amp; ret !== null) &#123; return ret; &#125; // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象 return res;&#125;// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的resvar p1 = New(Person, 'tom', 20);console.log(p1.getName());// 当然，这里也可以判断出实例的类型了console.log(p1 instanceof Person); // true 原型123456789101112131415// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 通过prototye属性，将方法挂载到原型对象上// 实现复用 避免每次都生成一个新的 getName 方法Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的 __proto__ 都指向原型对象。而原型对象的constructor指向构造函数。 除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。 当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。 我们可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);console.log('name' in p1); // true in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。 12// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式isMobile = 'ontouchstart' in document; 除此之外，我们还可以使用更为简单的原型写法。 12345678function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123;&#125;, getAge: function() &#123;&#125;, sayHello: function() &#123;&#125;&#125; Person.prototype = {} 实际上是重新创建了一个 {} 对象并赋值给 Person.prototype，这里的 {} 并不是最初的那个原型对象。因此它里面并不包含 constructor 属性。为了保证正确性，我们必须在新创建的 {} 对象中显示的设置 constructor 的指向。即上面的 constructor: Person。 原型链原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。 1function add() &#123;&#125; 其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 基于原型链的特性，我们可以很轻松的实现继承。 继承我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。 首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。 12345// 构造函数的继承function cPerson(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125; 而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。 12345// 继承原型cPerson.prototype = new Person(name, age);// 添加更多方法cPerson.prototype.getLive = function() &#123;&#125;]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用几种继承方案]]></title>
    <url>%2F2019%2F01%2F14%2FJavaScript%E5%B8%B8%E7%94%A8%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[原型链继承 构造函数，原型和实例之间的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个原型对象的指针。 继承的本质是复制，即重写原型对象，代之以新类型的实例。 1234567891011121314151617function Animals() &#123; this.type = "animals";&#125;Animals.prototype.getType = function() &#123; return this.type;&#125;;function Cat() &#123; this.name = "cat";&#125;// 这里是关键，创建 Animals 的实例，并将该实例赋值给 Cat.prototypeCat.prototype = new Animals();var cat = new Cat();console.log(cat.getType()); 原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。 12345678910111213function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"var instance2 = new SubType();alert(instance2.colors); //"red,blue,green,black" 借用构造函数继承使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型） 1234567891011121314function Animals() &#123; this.colors = ["red", "blue", "green"];&#125;function Cat() &#123; //继承自Animals Animals.call(this);&#125;var cat1 = new Cat();alert(cat1.colors); //"red,green,blue,black"var cat2 = new Cat();alert(cat2.colors); //"red,green,blue" 核心代码是Animals.call(this)，创建子类实例时调用Animals构造函数，于是Cat的每个实例都会将Animals中的属性复制一份。 缺点： 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现复用，每个子类都有父类实例函数的副本，影响性能 组合继承组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。 1234567891011121314151617181920212223242526272829303132333435function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 // 第二次调用SuperType() SuperType.call(this, name); this.age = age;&#125;// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType();// 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"instance1.sayName(); //"Nicholas";instance1.sayAge(); //29var instance2 = new SubType("Greg", 27);alert(instance2.colors); //"red,blue,green"instance2.sayName(); //"Greg";instance2.sayAge(); //27 缺点： 第一次调用SuperType()：给SubType.prototype写入两个属性 name，color。 第二次调用SuperType()：给instance1写入两个属性 name，color。 实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。 原生式继承利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。 12345function create(obj)&#123; fuction F()&#123;&#125;; fn.prototype = obj; return new F();&#125; create()对传入其中的对象执行了一次浅复制，将构造函数 F 的原型直接指向传入的对象。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = create(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = create(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" 缺点： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数 另外，ES5 中存在Object.create()的方法，能够代替上面的 object 方法。 寄生式继承核心：在原型式继承的基础上，增强对象，返回构造函数 12345678function createAnother(original) &#123; var clone = create(original); // 通过调用 create() 函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强对象 alert("hi"); &#125;; return clone; // 返回这个对象&#125; 函数的主要作用是为构造函数新增属性和方法，以增强函数 123456var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //"hi" 缺点（同原型式继承）; 寄生组合式继承结合借用构造函数传递参数和寄生模式实现继承 1234567891011121314151617181920212223242526272829303132333435function inhertPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本 prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性 subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型&#125;// 父类初始化实例属性和原型属性function SuperType(name) &#123; this.name = name; this.color = ["red", "yellow"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance1 = new SubType("xyc", 23);var instance2 = new SubType("lxy", 23);instance1.colors.push("2"); // ["red", "blue", "green", "2"]instance1.colors.push("3"); // ["red", "blue", "green", "3"] 这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf() 这是最成熟的方法，也是现在库实现的方法 ES6 类继承 extendsextends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的constructor方法，使用例子如下。 1234567891011121314151617181920212223242526272829303132333435363738394041class Rectangle &#123; // constructor constructor(height, width) &#123; this.height = height; this.width = width; &#125; // Getter get area() &#123; return this.calcArea() &#125; // Method calcArea() &#123; return this.height * this.width; &#125;&#125;const rectangle = new Rectangle(10, 20);console.log(rectangle.area);// 输出 200-----------------------------------------------------------------// 继承class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125;&#125;const square = new Square(10);console.log(square.area);// 输出 100 extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样 12345678910111213141516171819function _inherits(subType, superType) &#123; // 创建对象，创建父类原型的一个副本 // 增强对象，弥补因重写原型而失去的默认的constructor 属性 // 指定对象，将新创建的对象赋值给子类的原型 subType.prototype = Object.create(superType &amp;&amp; superType.prototype, &#123; constructor: &#123; value: subType, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superType) &#123; Object.setPrototypeOf ? Object.setPrototypeOf(subType, superType) : (subType.__proto__ = superType); &#125;&#125; 总结1、函数声明和类声明的区别函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个 ReferenceError。 1234let p = new Rectangle();// ReferenceErrorclass Rectangle &#123;&#125; 2、ES5 继承和 ES6 继承的区别 ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.call(this)）. ES6 的继承有所不同，实质上是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法，否则新建实例报错。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识总结-1]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[new 语法糖的实现1, 创建一个新的对象2, 链接到原型3, 绑定this4, 返回新的对象 123456789101112function create()&#123; // 创建一个新的对象 var obj = new Object(); // 获得构造函数 var fn = [].shift.call(arguments); // 链接到原型 obj.__proto__ = fn.prototype; // 绑定this 执行构造函数 var result = fn.apply(obj,arguments); // 确保返回的是对象 return typeof(result) === 'object' ? result : obj;&#125; 模拟实现Call 和 apply可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ 1234567891011121314Function.prototype.myCall = function(context)&#123; var context = context || window; // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') =&gt; a.fn = getValue context.fn = this; // this就是调用call的函数 // 将 context 后面的参数取出来 var args = [...arguments].slice(1); // getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24') var result = context.fn(...args); // 删除fn delete context.fn; return result;&#125; 以上就是 call 的思路，apply 的实现也类似 1234567891011121314Function.prototype.myApply = function(context)&#123; var context = context || window context.fn = this // 判断是否存在第二个参数 且为数组 if(arguments[1] &amp;&amp; Array.isArray(arguments[1]))&#123; var result = context.fn(...arguments[1]); &#125;else &#123; var result = context.fn(); &#125; delete context.fn; return result;&#125; bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; Vue双向绑定的简单实现（数据劫持和发布订阅）Vue内部实现实用了Object.defineProperty()和发布订阅模式来实现双向数据绑定。 123456789101112131415161718192021222324252627282930313233343536function observe(data)&#123; // 判断是不是对象 if(!obj || typeof data !== 'object')&#123; return; &#125; // 遍历对象， for(key in data)&#123; defineReactive(data,key,obj[key]); &#125;&#125;function defineReactive(data,key,value)&#123; // 递归子属性值 observe(value); Object.defineProperty(data,key,&#123; enumerable: true, configurable: true, get: function reactiveGetter()&#123; return value; &#125;, set:function reactiveSetter(newVal)&#123; value = newVal; &#125; &#125;)&#125;var data = &#123;name: 'Jay'&#125;;observe(data);data.name = 'John'; // set valuedata.name; // get value 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅。 1&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析compile如上模板代码时，遇上 就会给属性 name 添加发布订阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通过 Dep 解耦class Dep()&#123; constructor()&#123; this.subs = []; &#125; // 订阅 addSub( sub )&#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; // 发布 notify()&#123; this.subs.forEach( sub =&gt; &#123; sub.update(); &#125;) &#125;&#125;// 全局属性，通过该属性配置 Watcher 是watcher和dep关联的唯一桥梁，任何时候，都必须保证Dep.target只有一个值。Dep.target = null;function update()&#123; document.querySelector('div').innerText = value&#125;class Watcher()&#123; constructor(obj,key,cb)&#123; // 将 Dep.target 指向自己 Dep.target = this; this.cb = cb; this.obj = obj; this.key = key; this.value = obj[key]; // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 保证只有一个 Dep.target = null; &#125; update()&#123; // 获得新值 // this.value = this.obj[this.key]; ？？ 上面已经获取 这里应该不用二次获取了 // 调用 update 更新Dom this.cb(this.value); &#125;&#125;var data = &#123; name: 'yck' &#125;;observe(data);// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, 'name', update);// update Dom innerTextdata.name = 'yyy'; 接下来对 defineReactive改造 12345678910111213141516171819202122232425262728function defineReactive(data,key,value)&#123; observe(value); var dp = new Dep(); Object.defineProperty(data,key,&#123; enumerable: true, configurable: true, get: function reactiveGetter()&#123; console.log('get value') // 将 Watcher 添加到订阅 if(Dep.target)&#123; dp.addSub(Dep.target); &#125; return value; &#125;, set: function reactiveSetter(newVal)&#123; console.log('set value') value = newVal; // 执行 watcher 的 update 方法 dp.notify(); &#125; &#125;)&#125; 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。 前端缓存在介绍缓存的时候，我们习惯将缓存分为强缓存和协商缓存两种。两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。 强制缓存强制缓存判断HTTP首部字段：Cache-control，Expires。 Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用，是HTTP1.0标准下的字段。 Cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。如果同时存在Cache-control和Expires，浏览器总是使用Cache-control。 协商缓存协商缓存通过HTTP的Last-Modified，Etag字段进行判断。 Last-Modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送If-Modified-Since字段。服务器用本地Last-Modified时间与If-Modified-Since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。 Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。 附前端缓存最佳实践 JS函数 add(1)(2)(3)(4) 实现无限极累加问题：用 JS 实现一个无限累加的函数 add，示例如下： 123456add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 6add(1)(2)(3)(4)； // 10// 以此类推 思考🤔：我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回变量 a 就OK了。 实现： 12345678910111213function add(a)&#123; let count = 0; count = a; function sum(b)&#123; count += b; return sum; &#125; sum.toString = function()&#123; return count; &#125; return sum;&#125; 详细解析赋值、浅拷贝和深拷贝的区别一、赋值（Copy）赋值是将某一数值或对象赋给某个变量的过程，分为下面 2 部分 基本数据类型：赋值，赋值之后两个变量互不影响 引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响 二、浅拷贝（Shallow Copy） 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。 浅拷贝使用场景 Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 展开运算符 Spread 实际效果和 Object.assign() 是一样的 Array.prototype.slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 相应的还有concat等. 浅拷贝的实现 123456789function shallowClone(source) &#123; var target = &#123;&#125;; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; return target;&#125; 三、深拷贝（Deep Copy） 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。 深拷贝使用场景 JSON.parse(JSON.stringify(object)) 存在问题： undefined、symbol 和函数这三种情况，会直接忽略。 循环引用情况下，会报错。 new Date 情况下，转换结果不正确。解决方法转成字符串或者时间戳就好了。 jQuery.extend() lodash.cloneDeep() 深拷贝的自实现 其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。 123456789101112131415161718192021// 判是否是对象function isObject(obj) &#123; return typeof obj === 'object' &amp;&amp; obj != null;&#125;function cloneDeep2(source) &#123; if (!isObject(source)) return source; // 非对象返回自身 var target = Array.isArray(source) ? [] : &#123;&#125;; for(var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (isObject(source[key])) &#123; target[key] = cloneDeep2(source[key]); // 注意这里 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125; 词法作用域词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 词法作用域是在写代码或者定义时确定的，关注函数 在何处声明，作用域链基于代码嵌套。 动态作用域是在运行时确定的（this也是），关注函数 从何处调用，作用域链基于调用栈。 JavaScript并 不具备 动态作用域，它 只有词法作用域。但是this机制某种程度上很像动态作用域。 123456789101112// 词法作用域，关注函数在何处声明，a通过RHS引用到了全局作用域中的afunction foo() &#123; console.log( a ); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 理解 let 循环12345for (let i = 0; i &lt; 10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 1234567&#123; let j; for (j = 0; j &lt; 10; j++) &#123; let i = j; // 每个迭代重新绑定! console.log( i ); &#125;&#125; 变量提升 任何声明在某个作用域内的变量，都将附属于这个作用域。 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 var a = 2;会被看成两个声明，var a;和a = 2;，第一个声明在 编译阶段 进行，第二个赋值声明会被留在原地等待 执行阶段。 所有的声明（变量和函数）都会被 移动到各自作用域的最顶端，这个过程叫做提升 只有声明本身会被提升，而包括函数表达式在内的赋值或其他运行逻辑并不会提升。 函数声明和变量声明都会被提升，但是， 函数首先被提升，然后才是变量。 闭包当函数可以记住并访问所在的词法作用域，即使函数名是在当前词法作用域之外执行，这时就产生了闭包。 1234567891011function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 ---- 这就是闭包的效果 bar()在自己定义的词法作用域以外的地方执行。 bar()拥有覆盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用，不会被垃圾回收器回收 bar()持有对foo()内部作用域的引用，这个引用就叫做闭包。 定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写更优雅的JavaScript代码]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%BC%96%E5%86%99%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码技巧优先 ES6 新特性写法1234567891011121314151617181920212223242526272829303132333435// 箭头函数function foo()&#123; console.log('hello world')&#125;const foo = () =&gt; console.log('hello world')// 数组去重const formatArray = arr =&gt; [...new Set(arr)]// 数组合并const newArr = [...arr1, ...arr2, 'value']// 对象浅拷贝const newObj = &#123;...obj&#125;// 解构赋值const person = &#123;name: 'bao', age: 18&#125;const &#123; name, age &#125; = person// 常见对象属性取值前判断对象是否存在// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置render()&#123; const &#123; downloadList &#125; = this.props.store.downloadList let items = downloadList &amp;&amp; downloadList.items || [] let itemCount = downloadList &amp;&amp; downloadList.itemCount || 10 return &lt;Table dataSource=&#123;items&#125; pagination=&#123;&#123;total: itemCount&#125;&#125; /&gt;&#125;// 优化后render()&#123; const &#123; items, itemCount &#125; = this.props.manageStore.downloadList || &#123;&#125; return &lt;Table dataSource=&#123;items || []&#125; pagination=&#123;&#123;total: itemCount || 10&#125;&#125;/&gt;&#125; 优化逻辑判断语句大量的 if else 逻辑判断难以维护，且性能较差，可用多种方式代替 123456789101112131415161718192021222324252627// 对象配置法// 函数内部有条件判断，且 return 值时，满足条件立即return，而不要在结尾returnconst foo = v =&gt; &#123; if (v === "name") &#123; return "bao"; &#125; else if (v === "age") &#123; return "18"; &#125; else if (v === "height") &#123; return "180"; &#125;&#125;;const cfg = &#123; name: "bao", age: "18", height: "180"&#125;;const foo = v =&gt; cfg[v];// 数组配置法if (value === "hello" || value === "world" || value === "blabla") &#123; // ...&#125;// 配置数组形式const rightValue = ["hello", "world", "blabla"];if (rightValue.includes[value]) &#123; // ...&#125; 善用 &amp;&amp; 、 || 和 三元运算12345678910111213if (name === "bao") &#123; someFunc();&#125;name === "bao" &amp;&amp; someFunc();if (name === "bao") &#123; someFunc();&#125; else &#123; elseFunc();&#125;name === "bao" ? someFunc() : elseFunc(); 对象属性变量应用如在 react 中，调用 action 方法来获取数据，不同条件执行不同方法 12345678if (isMember) &#123; let res = await actions.getMemberInfo(params);&#125; else &#123; let res = await actions.getCommonUserInfo(params);&#125;const actionName = isMember ? "getMemberInfo" : "getCommonUserInfo";let res = await actions[actionName](params); 用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法12345678910111213141516171819202122let arr = [1, 2, 3, 4, "A", "B"];// 1. 取出 arr 中数字项为新数组let numArr = [];for (let i in arr) &#123; if (typeof arr[i] === "number") &#123; numArr.push(arr[i]); &#125;&#125;// 改用filterlet numArr2 = arr.filter(item =&gt; typeof item === "number");console.log(numArr2); // [1,2,3,4]// 2. 获得新数组，元素是 arr 每个元素作为 value, key 为 arr 下标的对象, 不修改 arrlet strArr = [];for (let i in arr) &#123; strArr.push(&#123; [i]: arr[i] &#125;);&#125;// 改用 maplet strArr2 = arr.map((item, i) =&gt; (&#123; [i]: arr[i] &#125;));console.log(strArr2); // [ &#123; '0': 1 &#125;,&#123; '1': 2 &#125;,&#123; '2': 3 &#125;, &#123; '3': 4 &#125;, &#123; '4': 'A' &#125;, &#123; '5': 'B' &#125; ] 浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 lodash.cloneDeep12345678910111213// 浅拷贝let obj1 = &#123; a: 11, b: &#123; ba: 22 &#125; &#125;;let obj2 = &#123; ...obj1 &#125;;console.log(obj2); // ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​console.log(obj1 === obj2); // falseconsole.log(obj2.b === obj1.b); // true// 深拷贝，这种方法需要对象能够被 json 序列化let obj3 = JSON.parse(JSON.stringify(obj1));console.log(obj3); // ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​console.log(obj3 === obj1); // falseconsole.log(obj3.b === obj1.b); // true 更高效的代码使用局部变量代替引用类型查找局部变量的读取速度最快，而引用类型的数据读取需要按引用指针去查找，所以可以对多次使用的引用类型属性 使用局部变量读取一次，重复使用 123456789101112let obj = &#123; person: &#123; man: &#123; bao: &#123; age: 18 &#125; &#125; &#125;&#125;;let age = obj.person.man.bao.age;// use age do many things 删除多个对象属性时先使属性为 null删除属性时，js 引擎会去查找该属性的值是否是其他对象的引用，所以删除前提前赋值为 null，可以减少 js 引擎的检测过程，提高效率 1234567891011let obj = &#123; person: &#123; man: &#123; bao: &#123; age: 18 &#125; &#125; &#125;&#125;;obj.person = null;delete obj.person;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之animation]]></title>
    <url>%2F2018%2F08%2F17%2FCSS3%E4%B9%8Banimation%2F</url>
    <content type="text"><![CDATA[首先，CSS Animation 需要指定动画一个周期持续的时间，以及动画效果的名称。 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 用 keyframes 关键字，定义 rainbow 效果。 1234567891011@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 上面的 animation 属性是简写，可以拆分成多个单独的属性 123456789div:hover &#123; animation-name: rainbow; // 效果名称 animation-duration: 1s; // 执行一次所需是时间 animation-timing-function: linear; // 动画的速度曲线, linear是匀速，还有ease, ease-in加速,ease-out减速，cubic-bezier(http://cubic-bezier.com) 自定义速度模式等 animation-delay: 1s; // 延时多久执行动画 animation-fill-mode: forwards; // 动画保持在结束状态, forwards是停在结束时，backwards 是停在开始时，none 回到动画没开始状态 animation-direction: normal; // 动画播放的方向, 有alternate（start-end -&gt; end-start -&gt; start-end）、reverse(end-start -&gt; end-start) animation-iteration-count: 3; // 动画执行次数 还有infinite&#125; 12345678div &#123; animation: rainbow 1s linear infinite; animation-play-state: paused; // 没有鼠标没有悬停时，动画状态是暂停；&#125;div:hover &#123; animation-play-state: running; // 一旦悬停，动画状态改为继续播放。&#125; 举个栗子：实现动画的播放，暂停和重新开始 html 部分 1234567&lt;div id="box" class="box"&gt;&lt;/div&gt;&lt;p id="text"&gt;&lt;/p&gt;&lt;div class="control"&gt; &lt;button id="play" value="播放"&gt;播放&lt;/button&gt; &lt;button id="pause" value="暂停"&gt;暂停&lt;/button&gt; &lt;button id="restart" value="重新开始"&gt;重新开始&lt;/button&gt;&lt;/div&gt; css 部分 12345678910111213141516171819202122232425262728293031323334353637@keyframes mymove &#123; 0% &#123; margin-left: 0px; &#125; 50% &#123; margin-left: 400px; &#125; 100% &#123; margin-left: 0px; &#125;&#125;@keyframes mymove1 &#123; 0% &#123; margin-left: 0px; &#125; 50% &#123; margin-left: 400px; &#125; 100% &#123; margin-left: 0px; &#125;&#125;.box &#123; margin: 50px 0; width: 100px; height: 100px; background-color: #5578a2;&#125;.play &#123; animation: mymove 5s infinite ease;&#125;.restart &#123; animation: mymove1 5s infinite ease;&#125;.pause &#123; animation-play-state: paused;&#125; js 部分 1234567891011121314151617181920212223242526272829303132var play = document.getElementById("play"), pause = document.getElementById("pause"), restart = document.getElementById("restart"), text = document.getElementById("text"), box = document.getElementById("box");// 暂停pause.addEventListener("click", function() &#123; if (box.classList.contains("play")) &#123; box.className = "pause play box"; &#125; else &#123; box.className = "pause restart box"; &#125; text.innerHTML = this.value;&#125;);// 播放play.addEventListener("click", function() &#123; if (box.classList.contains("play")) &#123; box.className = "play box"; &#125; else &#123; box.className = "restart box"; &#125; text.innerHTML = this.value;&#125;);// 重新开始restart.addEventListener("click", function() &#123; if (box.classList.contains("play")) &#123; box.className = "restart box"; &#125; else &#123; box.className = "play box"; &#125; text.innerHTML = this.value;&#125;); 参考资料CSS3 animation 属性妙用]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（原生函数）]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原生函数（native function）,也是 JavaScript 的内建函数（built-in function）.常见的原生函数有： String() Number() Boolean() Array() Object() Function() RegExp() Date() Error() Symbol() 原生函数可以被当做构造函数来使用，但是构造出来的对象和我们设想的不太一样 1234567var a = new String('123');typeof a; // 'object' 不是 ‘string’a instanceof String // trueObject.Prototype.toString.call(a) // '[object String]' 通过构造函数(如 new String(&#39;abc&#39;))创造出来的是封装了基本类型值（如‘abc’）的封装对象。 可以通过console.log(a)来查看封装对象。 需要注意的是，new String(&#39;abc&#39;)创造出来的是字符串’abc’的封装对象，而不是基本类型值’abc’。 内部属性[[class]]所有 typeof 返回值为“object”的对象都包含一个内部属性[[class]],这个属性无法访问，只能通过Object.prototype.toString()来查看。 1Object.prototype.toSting([1, 2, 3]); // [object Array] 数组的内部[[class]]属性值是“Array”。对象的内部[[class]]属性和创建该对象的内建函数相对应。但是 12Object.prototype.toString(null); // '[object Null]'Object.prototype.toString(undefined); // '[object Undefined]' 虽然是’null’和’undefined’这样的原生函数并不存在，但是内部[[class]]的属性值仍然是‘Null’和‘Undefined’ 其他的基本类型值（如字符串，布尔，数字）的情况有所不同，通常称为‘包装’（boxing）; 123Object.prototype.toString("123"); // [object String]Object.prototype.toString(123); // [object Number]Object.prototype.toString(false); // [object Boolean] 上面的基本类型值被各自的封装对象包装，所以他们的内部[[class]]属性值“String”,“Number”,“Boolean”。 封装对象包装封装对象（object wrapper）扮演者重要的角色。我们都知道基本类型没有.length 和.toString()这样的属性和方法，那他们是如何做到的呢？没错！就是通过封装对象访问的。此时 JavaScript 会自动为 基本类型值 包装（box 或者 wrap）一个封装对象。 1234var a = "abc";a.length; // 3a.toUpperCase(); // ABC 这时候我们会想：如果我们要经常使用属性和方法。为甚不一开始就创建封装对象，这样 JavaScript 引擎就不用每次都自动创建了。But~~实际上 浏览器已经做了性能优化，直接使用封装对象反而会降低执行效率。所以我们不需要直接使用封装对象，让 JS 引擎自己去决定什么时候使用封装对象。 封装对象释疑比如 Boolean 12345var a = new Boolean(false);if (!a) &#123; console.log("Oops"); // 实际上不会执行到这里&#125; 我们为 false 创建了一个封装对象，然而该对象总是返回真值（truthy）。 ✔️ 如果想要自行封装基本类型值，可以使用Object(..)函数（不带 new 关键字） 12345678910111213var a = "abc";var b = new String(a);var c = Object(a);typeof a; // stringtypeof b; // objecttypeof c; // objectb instanceof String; // truec instanceof String; // trueObject.prototype.toString.call(b); // [object String]Object.prototype.toString.call(c); // [object String] 再次强调，我们一般不推荐使用封装对象。 拆封✔️ 如果想得到封装对象中的基本类型值，可以使用valueOf()函数： 1234567var a = new String("abc");var b = new Number(22);var c = new Boolean(false);a.valueOf(); // 'abc'b.valueOf(); // 22c.valueOf(); // true 在需要用到封装对象中的基本类型值得地方会发生隐式拆封。 12345var a = new String("abc");var b = a + "";typeof a; // 'object'typeof b; // 'string' 原生函数作为构造函数关于数组（array），对象（object），函数（function）和正则表达式，实际上，使用常量和使用构造函数效果是一样的。（创建的值都是通过封装对象来包装）。 Array(..)123456// 构造函数Array(..)不要求必须带 new 关键字，不带时，它会被自动补上var a = new Array(1, 2, 3);a; // [1,2,3]var b = [1, 2, 3];b; // [1,2,3] Array 构造函数只带一个参数时，会被作为数组的预设长度(length),创造出来的只是一个空数组。 我们将包含至少一个“空单元”的数组称为“稀疏数组”. Date(..)和 Error(..)创建日期对象必须使用 new Date()。 Date(..)主要是用来获取当前的 Unix 时间戳（从 1970 年 1 月 1 日开始计算。以秒为单位）。 构造函数 Error(..)带不带 new 关键字都可以。创建错误对象（error object）主要是为了获得当前运行栈的上下文。栈的上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。 错误对象通常与 throw 一起使用。 12345function fn(x) &#123; if (x) &#123; throw new Error("x was not be provided"); &#125;&#125; 错误对象至少包含一个 message 属性。最好的办法是调用 toSting()来获得经过格式化的便于阅读的错误信息。 Symbol()ES6 中新加入了一个基本数据类型–符号（Symbol）。符号是具有唯一性的特殊值（并非绝对）。用它来命名对象属性不容易导致重名。 符号可以用作属性名，但是无论是在代码还是控制台上都无法查看和访问它的值，只会显示为诸如Symbol(Symbol.create)这样的值。 ES6 中有一些预定义符号，以 Symbol 的静态属性形式出现， 如 Symbol.create,Symbol.iterator 等。可以这样用： 123obj[Symbol.iterator] = function() &#123; /*..*/&#125;; ✔️ 我们可以使用 Symbol(..)原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会报错： 123456789var mysym = Symbol("my own symbol");mysym; // Symbol(my own symbol)mysym.toString(); // "Symbol(my own symbol)"typeof mysym; // 'symbol'var a = &#123;&#125;;a[mysym] = "abc";Object.getOwmPropertySymbols(a); // [Symbol(my own symbol)] 虽然符号实际上并非私有属性（通过Object.getOwmPropertySymbols(..)便可以公开获得对象中的所有符号），但是它却主要用于私有或者特殊属性。很多人稀罕用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖节流]]></title>
    <url>%2F2018%2F07%2F20%2F%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 上面代码使用例子： 1234567891011121314var count = 1;var container = document.getElementById('container');function getUserAction(e) &#123; container.innerHTML = count++;&#125;;var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;document.getElementById("button").addEventListener('click', function()&#123; setUseAction.cancel();&#125;) debounced解析 节流节流的原理很简单： 如果你持续触发事件，每隔一段时间，只执行一次事件。 根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。 使用时间戳123456789101112131415function throttle(func,wait)&#123; var time = 0, context, args; return function()&#123; context = this; args = arguments; var now = +new Date(); // 执行条件 if(now - time &gt; wait)&#123; func.apply(context,args); time = now; &#125; &#125;&#125; 使用定时器123456789101112131415function throttle(func, wait)&#123; var timer, context, args; return function()&#123; context = this; args = argumens; if(!timer) &#123; timer = setTimeout(function()&#123; func.apply(context,args); timer = null; &#125;,wait) &#125; &#125;&#125; 比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 合并123456789101112131415161718192021222324252627282930function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 但是我有时也希望无头有尾，或者有头无尾，这个咋办？ 那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定: leading：false 表示禁用第一次执行trailing: false 表示禁用停止触发的回调 1234567891011121314151617181920212223242526272829303132function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; throttle解析]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript立即执行函数(IIFE)与闭包]]></title>
    <url>%2F2018%2F06%2F22%2FJavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-IIFE-%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言一直没搞清楚立即执行函数和闭包之间的关系，总结一下： 闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包； 闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用； 立即执行函数只是一种函数的调用方式； 闭包的目的则是外部函数可以访问内部函数的作用域； 立即执行函数（IIFE）立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了； 一般情况下，只对匿名函数使用这种 立即执行函数 。它的核心是 闭包 ，实现的目的有以下几个： 不必为函数命名，避免污染全局变量； *内部形成单独的块级作用域，封装一些私有变量； 内部变量执行完即销毁，不会占用更多的内存。 javascript 中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 javascript 函数作用域链的特性，可以使用 IIFE 可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 定义一个函数，函数后面加上括号，即可完成调用； 1function ()&#123;&#125;(); // SyntaxError: Unexpected token ( 引擎在遇到关键字 function 时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了； 然后我们给它加上函数名: 123function abc()&#123;&#125;(); // SyntaxError: Unexpected token )//在一个表达式后面加上括号，表示该表达式立即执行；//而如果是在一个语句后面加上括号，该括号完全和之前的语句没什么关系，而只是一个分组操作符，用来控制运算中的优先级（小括号里的先运算）。 上面代码可以写成： 12function abc()&#123;&#125;; ();// SyntaxError: Unexpected token )//分组操作符内的表达式不能为空，执行到右括号时，发现表达式为空，所以报错。 然而函数表达式的函数名则可有可无； 在 function 前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = ； 我们在函数后面加上括号，然后再用另一个括号把它们都包起来； javascript 中，括号内不允许包含语句，但可以是表达式； 引擎先遇到括号，然后遇到关键字 function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明； 12345678910111213(function ()&#123;/*code*/&#125;());//javascript中，括号内不允许包含语句，但可以是表达式；//引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明 (function()&#123;/*code*/&#125;)(); //也可以这样写var a = function()&#123;/*code*/&#125;();//我们可以在函数表达式后面直接加括号，而不用把函数包起来；//但还是推荐外部加上()：var b = (function()&#123;/*code*/&#125;());var c = (function()&#123;/*code*/&#125;)();//因为外部如果没有()，我们得去function()&#123;/*code*/&#125;后面看是否存在()，判断b/c是一个函数还是一个函数内部的返回值//为了代码的可读性，还是要在外部加上()，无论是否已经是表达式； javascript 只有函数拥有局部作用域，立即执行函数也有这一特点，我们可以利用它减少全局变量造成的空间污染； 123456789(function abc()&#123; console.log(abc);//function abc()&#123;...&#125; var a = 1; console.log(a);//1&#125;)()console.log(abc);//ReferenceError: abc is not defined//函数表达式的标识符在外部作用域是找不到的，只有内部作用域可以找到//立即执行函数的函数名在外部也是找不到的 闭包(closure)闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作；简单的说，外部作用域就可以访问函数内部作用域的变量了。 由于作用域的关系，我们在函数外部是无法直接访问到函数内部的变量的，但是函数内部可以把这个变量传给全局变量或者返回出来，这样外部作用域就可以访问函数内部作用域的变量了； 简单的说，闭包就是有权限访问另一个函数内部作用域的变量的函数； javascript 具有自动垃圾回收机制，函数运行完之后，其内部的变量和数据会被销毁； 但是闭包就是在外部可以访问此函数内部作用域的变量，所以闭包的一个特点就是只要存在引用函数内部变量的可能，JavaScript 就需要在内存中保留这些变量。而且 JavaScript 运行时需要跟踪这个内部变量的所有外部引用，直到最后一个引用被解除（主动把外部引用赋为 null 或者页面关闭），JavaScript 的垃圾收集器才能释放相应的内存空间；这句话不是很好理解，下面用代码展示； 1234567891011121314151617181920212223242526function outer()&#123; var a = 1; function inner()&#123; return a++; &#125; return inner;&#125;var abc = outer();//outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中；//outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了；console.log(abc());//1console.log(abc());//2//因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的var def = outer();console.log(def());//1console.log(def());//2//再次把outer()函数赋给一个新的变量def，相当于绑定了一个新的outer实例；//console.log(a);//ReferenceError: a is not defined//console.log(inner);//ReferenceError: a is not defined//由于作用域的关系我们在外部还是无法直接访问内部作用域的变量名和函数名abc = null;//由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存； 立即执行函数能配合闭包保存状态 12345678910111213for(var i = 0; i &lt; 3; i++)&#123; setTimeout(function()&#123; console.log(i); //3 3 3 //在执行到这一行时，发现匿名函数里没有i，然后向往外部作用域找，然后找到的其实是for循环执行完了的i，也就是2++，3 &#125;,0);&#125;;for(var i = 0; i &lt; 3; i++)&#123; setTimeout((function(x)&#123; console.log(x); //0 1 2 &#125;)(i),0); //在立即执行函数内部i传给了x，并且锁在内存中，所以不会变&#125;; 插件用立即函数配合闭包写插件，防止变量全局污染，以及保证内部变量的安全； 1234567891011121314151617181920var Person = (function()&#123; var _sayName = function(str)&#123; str = str || 'shane'; return str; &#125; var _sayAge = function(age)&#123; age = age || 18; return age; &#125; return &#123; SayName : _sayName, SayAge : _sayAge &#125;&#125;)();//通过插件提供的API使用插件console.log(Person.SayName('lucy')); //lucyconsole.log(Person.SayName());//shaneconsole.log(Person.SayAge());//18 一道经典面试题下面的 ul 中，如何点击每一个 li 的时候弹出其下标? 12345&lt;ul&gt; &lt;li&gt;index 00000&lt;/li&gt; &lt;li&gt;index 11111&lt;/li&gt; &lt;li&gt;index 22222&lt;/li&gt;&lt;/ul&gt; 方法一： 闭包 12345678910111213141516171819window.onload = function()&#123; var oLi = document.getElementsByTagName('ul')[0].children; for (var i = 0; i &lt; oLi.length; i++)&#123; // 第一种写法 (function(index)&#123; oLi[index].onclick = function()&#123; console.log(index); &#125;; &#125;)(i); // 第二种写法 oLi[i].onclick = (function(index)&#123; return function()&#123; console.log(index); &#125; &#125;)(i); &#125;&#125; 方法二： 将下标作为对象的一个属性，添加到每个数组元素中，（name: “ i “, value: i 的值）; 123456789window.onload = function()&#123; var oLi = document.getElementsByTagName('ul')[0].children; for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].i = i; oLi[i].onclick = function()&#123; console.log(this.i); &#125;; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之发布订阅模式]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！ 其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法 再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来 那么废话不多说了，先来看看发布订阅模式到底何方神圣吧 说到发布订阅模式，它其实是一种对象间一对多的依赖关系(不是综艺节目以一敌百那种)，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知. 作用 广泛用于异步编程中（替代了传统回调函数） 对象之间松散耦合的编写代码 当然，胖子也不是一天吃成的。所以我们要想实现一个自己的发布订阅模式，以后在工作中使用，也需要一点点来的，表捉急，先从最简单的说起。 自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041let corp = &#123;&#125;; // 自定义一个公司对象// 这里放一个列表用来缓存回调函数corp.list = [];// 订阅事件corp.on = function(fn)&#123; // 直接把fn先存到列表中 this.list.push(fn);&#125;// 发布事件corp.emit = function()&#123; // 当发布的时候再把列表里存的函数依次执行 this.list.forEach( cb =&gt; &#123; cb.apply(this,arguments); &#125;)&#125;;// 测试用例corp.on(function (position, salary) &#123; console.log('你的职位是：' + position); console.log('期望薪水：' + salary);&#125;);corp.on(function(skill, hobby) &#123; console.log('你的技能有： ' + skill); console.log('爱好： ' + hobby);&#125;);corp.emit('前端', 10000);corp.emit('端茶和倒水', '足球');/* 你的职位是：前端 期望薪水：10000 你的技能有： 前端 爱好： 10000 你的职位是：端茶和倒水 期望薪水：足球 你的技能有： 端茶和倒水 爱好： 足球*/ 上面通过自定义事件实现了一个简单的发布订阅模式，不过从打印出来的结果来看，有点小尴尬。Why？ 因为在正常的情况下，希望打印的是酱紫的： 123456/* 你的职位是：前端 期望薪水：10000 你的技能有： 端茶和倒水 爱好： 足球*/ 之所以出现此种情况，那是在on方法的时候一股脑的都将fn函数全部放到了列表中。然而需要的只是一个简单的key值，就可以解决了。让我们改写一下上面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let corp = &#123;&#125;;// 这次换成一个对象类型的缓存列表corp.list = &#123;&#125;;corp.on = function(key,fn)&#123; // 如果对象中没有对应的key值 // 也就是说明没有订阅过 // 那就给key创建个缓存列表 if(!this.list[key])&#123; this.list[key] = []; &#125; // 把函数添加到对应key的缓存列表里 this.list[key].push(fn);&#125;corp.emit = function()&#123; // 第一个参数是对应的key值 // 直接用数组的shift方法取出 let key = [].shift.call(arguments); // 获取该键值中存在的所有函数 fns = this.list[key]; // 如果不存在或者没有返回 if(!fns || fns.length ==== 0) return false; // 遍历key值对应的缓存列表 // 依次执行函数的方法 fns.forEach( cb =&gt; &#123; cb.apply(this,arguments) &#125;)&#125;// 测试用例corp.on('join', (position, salary) =&gt; &#123; console.log('你的职位是：' + position); console.log('期望薪水：' + salary);&#125;);corp.on('other', (skill, hobby) =&gt; &#123; console.log('你的技能有： ' + skill); console.log('爱好： ' + hobby);&#125;);corp.emit('join', '前端', 10000);corp.emit('join', '后端', 10000);corp.emit('other', '端茶和倒水', '足球');/* 你的职位是：前端 期望薪水：10000 你的职位是：后端 期望薪水：10000 你的技能有： 端茶和倒水 爱好： 足球*/ 来个通用的现在来搞个通用的发布订阅模式实现，和刚才的差不多，不过这次起名也要隆重些了，直接叫event吧，看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let event = &#123; list: &#123;&#125;, // 订阅 on(key,fn)&#123; if(!this.list[key])&#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, // 发布 emit()&#123; let key = [].shift.call(arguments); fns = this.list[key]; if(!fns || fns.length === 0)&#123; return false; &#125; fns.forEach( cb =&gt; &#123; cb.apply(this,arguments); &#125;) &#125;, // 取消订阅 remove(key,fn)&#123; let fns = this.list[key]; // 如果不存在对应的key if(!fns) return false; // 如果没有传入函数，就会将key值对应缓存列表中的函数都清空掉 if(!fn) fns &amp;&amp; (fns.length = 0); //如果都存在 fns.forEach( (cb,i) =&gt; &#123; if(cb === fn) &#123; fns.splice(i,1); &#125; &#125;) &#125;&#125;;function cat() &#123; console.log('一起喵喵喵');&#125;function dog() &#123; console.log('一起旺旺旺');&#125;event.on('pet', data =&gt; &#123; console.log('接收数据'); console.log(data);&#125;);event.on('pet', cat);event.on('pet', dog);// 取消dog方法的订阅event.remove('pet', dog);// 发布event.emit('pet', ['二哈', '波斯猫']);/* 接收数据 [ '二哈', '波斯猫' ] 一起喵喵喵*/ 这样其实就实现了一个可以使用的发布订阅模式了，其实说起来也是比较简单的，来一起屡屡思路吧. 思路： 创建一个对象(缓存列表) on方法用来把回调函数fn都加到缓存列表中 emit方法取到arguments里第一个当做key，根据key值去执行对应缓存列表中的函数 remove方法可以根据key值取消订阅 总结优点： 对象之间的解耦 异步编程中，可以更松耦合的代码编写 缺点： 创建订阅者本身要消耗一定的时间和内存 多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 强如发布订阅模式，也是劲酒虽好，不要贪杯的道理哦。过度使用的话，都会出现上述缺点的问题。不过合理开发合理利用，这都不是什么大问题的。 原文]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。 二分搜索树二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。 这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。 实现123456789101112131415161718192021222324252627282930313233343536class Node &#123; constructor(value) &#123; this.value = value this.left = null this.right = null &#125;&#125;class BST &#123; constructor() &#123; this.root = null this.size = 0 &#125; getSize() &#123; return this.size &#125; isEmpty() &#123; return this.size === 0 &#125; addNode(v) &#123; this.root = this._addChild(this.root, v) &#125; // 添加节点时，需要比较添加的节点值和当前 // 节点值的大小 _addChild(node, v) &#123; if (!node) &#123; this.size++ return new Node(v) &#125; if (node.value &gt; v) &#123; node.left = this._addChild(node.left, v) &#125; else if (node.value &lt; v) &#123; node.right = this._addChild(node.right, v) &#125; return node &#125;&#125; 以上是最基本的二分搜索树实现，接下来实现树的遍历。 对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。 以下都是递归实现，如果你想学习非递归实现，可以 点击这里阅读 123456789101112131415161718192021222324252627282930313233343536373839// 先序遍历可用于打印树的结构// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。preTraversal() &#123; this._pre(this.root)&#125;_pre(node) &#123; if (node) &#123; console.log(node.value) this._pre(node.left) this._pre(node.right) &#125;&#125;// 中序遍历可用于排序// 对于 BST 来说，中序遍历可以实现一次遍历就// 得到有序的值// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。midTraversal() &#123; this._mid(this.root)&#125;_mid(node) &#123; if (node) &#123; this._mid(node.left) console.log(node.value) this._mid(node.right) &#125;&#125;// 后序遍历可用于先操作子节点// 再操作父节点的场景// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。backTraversal() &#123; this._back(this.root)&#125;_back(node) &#123; if (node) &#123; this._back(node.left) this._back(node.right) console.log(node.value) &#125;&#125; 以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。 12345678910111213141516breadthTraversal() &#123; if (!this.root) return null let q = new Queue() // 将根节点入队 q.enQueue(this.root) // 循环判断队列是否为空，为空 // 代表树遍历完毕 while (!q.isEmpty()) &#123; // 将队首出队，判断是否有左右子树 // 有的话，就先左后右入队 let n = q.deQueue() console.log(n.value) if (n.left) q.enQueue(n.left) if (n.right) q.enQueue(n.right) &#125;&#125; 接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反 1234567891011121314getMin() &#123; return this._getMin(this.root).value&#125;_getMin(node) &#123; if (!node.left) return node return this._getMin(node.left)&#125;getMax() &#123; return this._getMax(this.root).value&#125;_getMax(node) &#123; if (!node.right) return node return this._getMin(node.right)&#125; 向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。 12345678910111213141516floor(v) &#123; let node = this._floor(this.root, v) return node ? node.value : null&#125;_floor(node, v) &#123; if (!node) return null if (node.value === v) return v // 如果当前节点值还比需要的值大，就继续递归 if (node.value &gt; v) &#123; return this._floor(node.left, v) &#125; // 判断当前节点是否拥有右子树 let right = this._floor(node.right, v) if (right) return right return node&#125; 排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node &#123; constructor(value) &#123; this.value = value this.left = null this.right = null // 修改代码 this.size = 1 &#125;&#125;// 新增代码_getSize(node) &#123; return node ? node.size : 0&#125;_addChild(node, v) &#123; if (!node) &#123; return new Node(v) &#125; if (node.value &gt; v) &#123; // 修改代码 node.size++ node.left = this._addChild(node.left, v) &#125; else if (node.value &lt; v) &#123; // 修改代码 node.size++ node.right = this._addChild(node.right, v) &#125; return node&#125;select(k) &#123; let node = this._select(this.root, k) return node ? node.value : null&#125;_select(node, k) &#123; if (!node) return null // 先获取左子树下有几个节点 let size = node.left ? node.left.size : 0 // 判断 size 是否大于 k // 如果大于 k，代表所需要的节点在左节点 if (size &gt; k) return this._select(node.left, k) // 如果小于 k，代表所需要的节点在右节点 // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量 if (size &lt; k) return this._select(node.right, k - size - 1) return node&#125; 接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况 需要删除的节点没有子树 需要删除的节点只有一条子树 需要删除的节点有左右两条树 对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。 1234567891011121314delectMin() &#123; this.root = this._delectMin(this.root) console.log(this.root)&#125;_delectMin(node) &#123; // 一直递归左子树 // 如果左子树为空，就判断节点是否拥有右子树 // 有右子树的话就把需要删除的节点替换为右子树 if ((node != null) &amp; !node.left) return node.right node.left = this._delectMin(node.left) // 最后需要重新维护下节点的 `size` node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125; 最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。 当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。 你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。 12345678910111213141516171819202122232425262728293031delect(v) &#123; this.root = this._delect(this.root, v)&#125;_delect(node, v) &#123; if (!node) return null // 寻找的节点比当前节点小，去左子树找 if (node.value &lt; v) &#123; node.right = this._delect(node.right, v) &#125; else if (node.value &gt; v) &#123; // 寻找的节点比当前节点大，去右子树找 node.left = this._delect(node.left, v) &#125; else &#123; // 进入这个条件说明已经找到节点 // 先判断节点是否拥有拥有左右子树中的一个 // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样 if (!node.left) return node.right if (!node.right) return node.left // 进入这里，代表节点拥有左右子树 // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值 let min = this._getMin(node.right) // 取出最小值后，删除最小值 // 然后把删除节点后的子树赋值给最小值节点 min.right = this._delectMin(node.right) // 左子树不动 min.left = node.left node = min &#125; // 维护 size node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort） 大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。 算法描述 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 先来实现一下冒泡排序： 123456789101112function bubbleSort(arr) &#123; let len = arr.length; if (len &lt;= 1) return arr; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 注意当算法执行外循环的第二轮时，最后两个数组已经是正确排序了，尽管如此，在后续的比较中，它们还一直在进行着比较，即便这是不必要的。因此，我们可以改进一下： 123456789101112function bubbleSort(arr) &#123; let len = arr.length; if (len &lt;= 1) return arr; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 改进冒泡排序： 设置一标志性变量 pos,用于记录每趟排序中最后一次进行交换的位置。由于 pos 位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到 pos 位置即可。 123456789101112131415161718function BubbleSort(arr) &#123; let len = arr.length; if (len &lt;= 1) return arr; let pos; // 先声明标志变量 var i = len - 1; //初始时,最后位置保持不变 while (i &gt; 0) &#123; pos = 0; //每趟开始时,无记录交换 for (var j = 0; j &lt; i; j++) if (arr[j] &gt; arr[j + 1]) &#123; pos = j; //记录交换的位置 var tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; i = pos; //为下一趟排序作准备 &#125; return arr;&#125; 冒泡排序动图演示 选择排序（Select Sort） 选择排序是一种简单直观的排序算法，它的工作原理是：首先找到数据结构中的最小值,然后将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。 1234567891011121314151617function SelectSort(arr) &#123; var len = arr.length; var indexMin, temp; for (var i = 0; i &lt; len - 1; i++) &#123; indexMin = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[indexMin] &gt; arr[j]) indexMin = j; // 找到最小的值，保存其索引 &#125; if (i !== indexMin) &#123; // 交换位置sels temp = arr[i]; arr[i] = arr[indexMin]; arr[indexMin] = temp; &#125; &#125; return arr;&#125; 选择排序动图演示 插入排序（Insertion Sort）算法介绍 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法的描述和实现一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 1234567891011121314function insertionSort(arr)&#123; var len = arr.length; var temp, j; for(var i=1; i&lt;len; i++)&#123; temp = arr[i]; j = i; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; return arr;&#125; 改进插入排序：查找插入位置时使用二分查找的方式 123456789101112131415161718192021222324function binaryInsertSort(arr) &#123; if (Array.isArray(arr)) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var key = arr[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; arr[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[left] = key; &#125; return array; &#125; else &#123; return "arr is not an Array"; &#125;&#125; 插入排序演示图示 归并排序(Merge Sort) 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。 算法介绍 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。 算法描述和实现具体算法描述如下： 把长度为 n 的输入序列分成两个长度为 n/2 的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 12345678910111213141516171819202122232425function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (arr &lt; 2) return arr; var middle = Math.floor(len / 2); left = arr.slice(0, middle); right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); result();&#125; 归并排序动图演示 快速排序（Quicksort） 快速排序是处理大数据最快的排序算法之一，它也是一种分而治之的算法，通过递归方式将数据依次分解为包含较小元素和较大元素的不同子序列，会不断重复这个步骤，直到所有的序列全部为有序的，最后将这些子序列一次拼接起来，就可得到排序好的数据。 算法描述和实现具体算法描述如下： 该算法首先要从数列中选出一个元素作为基数（pivot）。接着所有的数据都将围绕这个基数进行，将小于改基数的元素放在它的左边，大于或等于它的数全部放在它的右边，对左右两个小数列重复上述步骤，直至各区间只有1个数。 12345678910111213141516function quickSort(arr)&#123; if ( arr.length == 0) &#123; return []; &#125; var left = []; var right = []; var pivot = arr[0]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat( pivot, quickSort(right));&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入对象]]></title>
    <url>%2F2018%2F03%2F07%2FJavaScript%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[创建对象简单做法使用 Object 构造函数创建123// 对象实例的创建var obj = new Object();obj.key = "value"; //使用构造函数创建一个空对象，并赋值s 使用对象字面量表示法创建1234var obj = &#123; key1: "value1", key2: "value2"&#125;; 字面量表示法与 Object 构造函数创建法唯一的区别是，在字面量表示法里你可以给对象添加多个 键/值 对，但是在构造形式中你必须逐个添加属性。 现在 ES6 可以使用更简洁的方式创建对象： 123456789101112131415161718let age = 20;let sex = "sexy";let obj = &#123; name: "jay", // 简洁表示法，等同于 age: age age, // 简洁表示法，等同于 sayName： function() &#123;&#125; sayName() &#123;&#125;, //属性名表达式，等同于 lover:'rose' ["lo" + "ver"]: "rose", // 属性名表达式，等同于 sexy: 'male' [sex]: "male"&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ‘[object Object]’，这一点要特别小心。 工厂模式即用函数来封装创建对象的细节。多次调用该函数来创建多个相似对象。 123456789101112function createPerson(name, age) &#123; var o = &#123;&#125;; o.name = name; o.age = age; o.sayName = function() &#123; console.log(this); &#125;; return o;&#125;var a = createPerson("a", 20);var b = createPerson("b", 22); 工厂模式虽然解决多创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 模仿‘类’的设计构造函数模式构造函数包括像 Array,Object 这样的原生构造函数，他们在 js 运行时会自动出现在执行环境中。此外，我们可以创建自定义构造函数，从而定义自定义类型的属性和方法。现在构造函数重写上个例子： 12345678910function Person(name, age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; console.log(this); &#125;;&#125;let a = new Person("a", 20);a instanceof Person; // true 构造函数就是普通的函数，不存在特殊语法。构造函数与其他函数唯一的区别就在于调用他们的方式不同。任何函数只要通过new操作符来调用，那它就可以作为构造函数。使用new操作符调用函数，或者说发生构造函数调用时，会自动执行下面操作： 创建一个全新的对象。 这个新对象会被执行[[Prototype]] 链接。 这个新对象会绑定到函数调用时的 this。 如果函数没有返回其他对象，那么 new 表达式的函数调用会自动返回这个新对象。 由于构造函数调用时会自动执行 [[Prototype]] 链接，也就是把新对象的原型链指向构造函数的 prototype。所以使用instanceof或isPrototypeOf方法可以判断他们的类型。 上面这种构造函数解决了对象类型识别的问题，但是每个方法都要在每个实例上重新创建一遍，在上面的例子中，a 和 b 都有个名为sayName()的方法，这两个方法虽然名字、内容、功能相同，但却分别在 a 和 b 中都重新创建了一次，这是没有必要的。 更好的方法应该是将公用的方法放到他们的原型上，也就是接下来要说的原型模式。 原型模式所有函数都有一个不可枚举的 prototype(原型)属性，这个属性时一个指针，指向一个对象。 123function Foo() &#123;&#125;Foo.prototype; // &#123;&#125; 上一节【构造函数模式】里面有说，new操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 所指向的对象。 这里出现了一个重点词原型链，我们先解释下什么叫做原型链。 原型链也被称为 [[Prototype]]链，是对象的内置属性。原型链是 ECMAScript 中实现继承的主要办法，其基本思想就是让一个引用类型继承另一个引用类型的属性和和方法。 例如我们新建个对象 a，然后给它指定它的原型链的指向： 123456var a = &#123;&#125;;var b = &#123; x: 2 &#125;;Object.setPrototypeOf(a, b);a.x; // 2 这个例子中我们通过Object.setPrototypeOf()方法把 a 的原型链指向 b，然后 a 就继承了 b 的属性，当查询 a 中没有的 x 属性时，会指向到 b.x 的值。 这里原理上说是委托比说是继承更符合真实情况。因为真实情况如上段所说是 a 把自身没有的属性查询委托给 b，如果 b 中也没 x 属性的话，系统会继续循着原型链往上查。所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。如果 Object.prototype 也没有的话就会提示 undefined。 这里提示一下，由于所有普通的对象都”源于“（或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype 对象，所以它包含 Javascript 中许多通用的功能。 上面说过，new 操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 属性所指向的对象（即原型对象）。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。例如： 1234567891011function Person() &#123;&#125;Person.prototype = &#123; name: "h", sayName() &#123; alert(this.name); &#125;&#125;;var a = new Person();a.sayName(); // h 这种方法因为重写了 Person.prototype,所以默认的 Person.prototype.constructor 也会丢失，如果要修复 constructor,可以使用Object.defineProperty(). 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 不过实例一般都是要有属于自己的全部属性的。所以日常开发中设计对象更常见的做法是构造函数模式跟原型模式组合使用： 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;let a = new Person("Jack");a.sayName(); // Jack 这里很像一些面向“类”的语言的行为，a 和 b 是 Person 类的实例，a 和 b 继承了 Person 类的特性。但实际上 JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。 使用 ES6 Class上面说的原型是通过构造函数，定义并生成新对象。但这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。 不过需要注意的是， ES6 的 class 语法是并不是向 JavaScript 中引入了一种新的“ 类” 机制。 class 基本上只是现有 [[Prototype]] 机制的一种语法糖。 也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（ 有意或无意） 修改或者替换了父“ 类” 中的一个方法， 那子“ 类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。 ES6 的类，完全可以看作构造函数的另一种写法。 123class Foo &#123;&#125;typeof Foo; // 'function'Foo === Foo.prototype.constructor; // true 面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。 123456789101112class Foo &#123; constructor() &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;let a = new Foo("a");a.sayName(); // a 构造函数的 prototype 属性，在 ES6 的‘类’上继续存在，事实上，类的所有方法都定义上类的 prototype 属性上面。 123456789101112class Foo &#123; constructor() &#123;&#125; toString() &#123;&#125; toValue() &#123;&#125;&#125;// 等同于Foo.prototype = &#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;; 由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。 12345678class Foo &#123; constructor() &#123;&#125;&#125;Object.assign(Foo.prototype, &#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;); ES6 Class 与 普通构造函数的不同点主要有 4 个： (1)constructor 方法 constructor方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即 this），完全可以指定返回另外一个对象。 1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo; // false 上面代码中，constructor 函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。 类的构造函数，不使用 new 是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。 1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo();// TypeError: Class constructor Foo cannot be invoked without 'new' (2)类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与普通构造函数的行为不一致。 123456789101112/ classclass Foo &#123; constructor(name) &#123; this.name = name &#125; sayName()&#123; console.log(this.name) &#125;&#125;Object.keys(Foo.prototype) // []Object.getOwnPropertyNames(Foo.prototype) // ["constructor","sayName"] 1234567891011//构造函数function Foo(name) &#123; this.name = name;&#125;Foo.prototype.sayName = function() &#123; alert(this.name);&#125;;Object.keys(Foo.prototype); // ["sayName"]Object.getOwnPropertyNames(Foo.prototype); // ["constructor", "sayName"] 上面代码中，sayName 方法是 Foo 类内部定义的方法，它是不可枚举的。而定义在 Foo.prototype 中的话则是可枚举的。 (3) Class 不存在变量提升（hoist），这点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 (4)子类的继承 Class 之间可以通过 extends 关键字实现继承，这比普通构造函数通过修改原型链实现继承，要清晰和方便很多。 12class Foo &#123;&#125;class Bar extends Foo &#123;&#125; 上面代码定义了一个 Bar 类，该类通过 extends 关键字，继承了 Foo 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Foo 类。下面，我们在 Bar 内部加上代码。 1234567891011121314151617181920212223242526272829class Foo &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayProfile() &#123; return `hello, my name is $&#123;this.name&#125;, $&#123;this.age&#125; years old`; &#125;&#125;class Bar extends Foo &#123; constructor(name, age, lover) &#123; super(name, age); // 调用父类的 constructor(name,age), 约等于普通构造函数中的 Foo.call(this, name, age) this.age = Number(this.age) + 5; this.lover = lover; &#125; sayIntro() &#123; alert( super.sayProfile() + `, my lover is $&#123;this.lover&#125;, again, I am $&#123;this.name&#125;` ); &#125;&#125;var a = new Bar("Jack", "20", "Rose");a.sayIntro(); // "hello, my name is Jack, 25 years old, my lover is Rose, again, I am 上面代码中，子类 Bar 的constructor方法和sayIntro方法之中，都出现了super关键字，super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。在上面的代码中 子类 Bar 的构造函数中super(name, age)相当于Foo.prototype.constructor.call(this, name, age)。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 要注意的是，子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用super方法，子类就得不到 this 对象。在子类的构造函数中，只有调用super之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 普通构造函数的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Foo.call(this)）。ES6 Class 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用super方法），然后再用子类的构造函数修改 this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法： 123constructor (...args) &#123; super(...args);&#125; 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。上面代码代码中的 super.sayProfile()就是将super当作一个对象使用。这时，super在普通方法之中，指向 Foo.prototype，所以super.sayProfile()就相当于Foo.prototype.sayProfile()。 ES6 规定，通过super调用父类的方法时，super会绑定子类的 this。所以sayProfile输出的this.age是子类 Bar 的 age 25 岁。 刚刚说到在静态方法中super指向父类。 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static sayHi() &#123; return "hello"; &#125;&#125;Foo.sayHi(); // hellovar a = new Foo();a.sayHi(); // TypeError: a.sayHi is not a function 上面代码中ayHi()就是 Foo 的静态方法，它只能通过 Foo 调用，不能通过 Foo 的实例调用。 如果super作为对象用在静态方法中，这时super将指向父类，而不是父类的原型对象。 123456789101112131415161718class Foo &#123; static sayHi() &#123; // 父类 return "hello"; &#125; sayHi() &#123; // 原型 return "oops"; &#125;&#125;class Bar extends Foo &#123; static sayBob() &#123; return super.sayHi() + "Bob"; &#125;&#125;Bar.sayBob(); // 'hello Bob' 面向委托的设计（对象关联风格）有些开发者比较诟病这种模仿“类”的设计模式，因为继承意味着复制，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联（我们把这种关联成为原型链），这样对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中的对象关联机制。 即便通过 ES6 class 让 js 看起来更像“类”，也只是一种模仿的假象。在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 Javascript 最强大的特性就是它的动态性，任何对象的定义都可以修改（除非你把它定义为不可变）。 一些开发者认为 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但实际上却让问题更难解决且让 JavaScript 更难理解。因为它隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托机制。让本来简洁优雅的 [[Prototype]] 机制变的非常别扭。 我们比较下继承与委托设计的区别。 我们先想想类（继承）的设计方法：先定义一个通用的父类 F，在父类 F 中定义所有任务都有的行为，接着定义子类 a 和 b，他们都继承自父类并且会添加一些特殊行为来处理对应的任务。 再用委托的思想来考虑同样的问题：首先先定义一个对象 F，它包含所有任务都可以使用（委托）的具体行为。接着，对于每个任务你都会定义一个对象来储存对应的数据和行为，你会把特定的任务对象都关联到 F 功能对象上面，让他们在需要的时候可以进行委托。基本你可以想象成 a 和 F 之间是兄弟关系，a 完成不了的任务东西都委托给 F 完成。 JavaScript 中原型链实际上是委托的关系而不是继承。委托行为意味着某些对象在找不到属性或方法引用时会把这个请求委托给另一个对象。 我们先看一个使用类设计风格的例子： 1234567891011121314151617function Foo(name) &#123; this.name = name;&#125;Foo.prototype.intro = function() &#123; return "my name is " + this.name;&#125;;function Bar(name) &#123; Foo.call(this, name);&#125;Bar.prototype = Object.create(Foo.prototype);Bar.prototype.speak = function() &#123; alert(this.intro());&#125;;var a = new Bar("a");a.speak(); // my name is a 这个例子里子类 Bar 继承了父类 Foo，然后生成了 a 这个实例，a 通过 new 构造函数委托了 Bar.prototype，Bar.prototype 通过Object.create()方法委托了 Foo.prototype()。这种风格很常见，你应该已经熟悉了。 当然我们可以用 class 让这段代码看起来更简洁明了： 123456789101112131415161718192021class Foo &#123; constructor(name) &#123; this.name = name; &#125; intro() &#123; return "my name is " + this.name; &#125;&#125;class Bar extends Foo &#123; constructor(name) &#123; super(name); &#125; speak() &#123; alert(super.intro()); &#125;&#125;var a = new Bar("a");a.speak(); 现在再来看看同例的对象关联风格的设计： 123456789101112131415161718Foo = &#123; init: function(name) &#123; this.name = name; &#125;, intro: function() &#123; return "my name is " + this.name; &#125;&#125;;Bar = Object.create(Foo);Bar.speak = function() &#123; alert(this.intro());&#125;;var a = Object.create(Bar);a.init("a");a.speak(); 这段代码中我们同样利用 [[Prototype]] 把 a 委托给 Bar 并把 Bar 委托给 Foo，和上段代码一样，我们仍然实现了三个对象的关联。 但非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。 对象的内容对象的内容是由一些储存在特定命名位置的（任意类型的）值组成的，我们称之为属性。 getter 与 settergetterget 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。该方法会覆盖单个属性默认的 [[Get]] 操作（获得属性值的操作）。 用法： {get prop() { … } } // prop 为要绑定到给定函数的属性名 {get expression { … } } //从 ECMAScript 2015 (ES6)开始，还可以使用一个计算的属性名的表达式绑定到给定的函数。 例如： 12345678910111213141516171819var myObj = &#123; get a() &#123; return 2; &#125;&#125;;// 也可以通过 defineProperty 创建Object.defineProperty(myObj, "b", &#123; get: function() &#123; return this.a * 2; &#125;, enumable: true&#125;);myObj.a; // 2myObj.b; // 4myObj.a = 3;myObj.a; // 2 如上面例子，不管是对象文字语法中的get a() { .. }， 还是defineProperty(...)中的显式定义， 二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。 同时由于我们只定义了 a 的 getter， 所以对 a 的值进行设置时 set 操作会忽略赋值操作，且不会抛出错误。 为了让属性更合理， 我们还应当定义 setter。 setterset 语法会覆盖单个属性默认的 [[Put]] 操作（赋值操作）。 通常来说 getter 和 setter 是成对出现的（ 只定义一个的话通常会产生意料之外的行为）。 例如： 1234567891011var myObj = &#123; get a() &#123; return this._a_; &#125;, set a(val) &#123; this._a_ = val * 2; &#125;&#125;;myObj.a = 2;myObj.a; // 4 注意，在本例中， 实际上我们把赋值（ [[Put]]） 操作中的值 2 存储到了另一个变量_a_中。 名称_a_只是一种惯例， 没有任何特殊的行为，和其他普通属性一样。 遍历对象属性for…infor keys in object 循环可以遍历对象的可枚举属性列表（包括 [[Prototype]] 原型链）。 for..in循环是无法直接获取属性值的，你需要手动获取属性值。 需要注意的是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。 for…offor..of循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。 我们先看一下迭代器的定义： 可迭代协议 可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array、Map, 另一些类型则不是 (比如 Object) 。 为了变成可遍历对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链上的某个对象）必须有一个名字是 Symbol.iterator 的属性: 数组有内置的 @@iterator， 因此for..of可以直接应用在数组上: 1234567var myArr = [1, 2, 3];for (var v of myArr) &#123; console.log(v);&#125;// 1// 2// 3 我们再通过数组的Symbol.iterator属性看看@@iterator是怎么工作的： 123456var myArr = [1, 2, 3];it = myArr[Symbol.iterator]();it.next(); // &#123;value: 1, done: false&#125;it.next(); // &#123;value: 2, done: false&#125;it.next(); // &#123;value: 3, done: false&#125;it.next(); // &#123;value: undefined, done: true&#125; 如你所见，调用迭代器的next()方法会返回形式为{value: .., done: ..}的值，value是当前的遍历值，done是一个布尔值，表示是否还有可以遍历的值。 上面示例中需要注意的一点，我们使用符号Symbol.iterator来获取对象的@@iterator内部属性。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但@@iterator本身并不是迭代器对象，而是返回迭代器对象的函数——这点非常精妙并且重要。 可是普通对象没有内置的@@iterator，所以无法完成for..of遍历。制定者之所以这样做，有许多复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。 但我们可以给任何想遍历的对象自定义@@iterator，例如： 1234567891011121314151617181920212223242526272829303132var myObj = &#123; a: 1, b: 2 &#125;;Object.defineProperty(myObj, Symbol.iterator, &#123; enumerable: false, writable: false, configurable: true, value: function() &#123; var o = this; var idx = 0; var ks = Object.keys(o); return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: idx &gt; ks.length &#125;; &#125; &#125;; &#125;&#125;);// 手动遍历 myObjvar it = myObj[Symbol.iterator]();it.next(); // &#123;value: 1, done: false&#125;it.next(); //&#123;value: 2, done: false&#125;it.next(); //&#123;value: undefined, done: true&#125;// 用 for..of 遍历 myObjfor (var v of myObj) &#123; console.log(v);&#125;// 1// 2 对象的代理 ProxyES6 中引入的 Proxy 是一个元编程的特性。元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。 Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。也就说它可以 “代理” 对象的原生行为，替换为执行自定义行为。 Proxy 语法如下： 1let p = new Proxy(target, handler); 其中，new Proxy()表示生成一个 Proxy 实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 举个栗子，我们知道当我们要获取对象的属性值的时候，对象内部会调用 get 方法去获取这个属性，如果该属性不存在在该对象中，则会继续向 [[Prototype]] 原型链向上寻找，一直找到 Object.prototype。 如果我们按上一节的方法给该属性设置了get()方法，则查询该属性值时会返回get() 方法的返回值。Proxy 可以给所有查询不到的属性设置统一的get()方法。 例如： 12345678910var a = &#123; x: 2 &#125;;var obj = new Proxy(a, &#123; get: function(target, name) &#123; return name in target ? target[name] : 3; &#125;&#125;);obj.x; // 2obj.y; // 3obj.z; // 3a.y; // undefined 需要注意的是，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var a = &#123; x: 2 &#125;;var obj = new Proxy(a, &#123;&#125;);obj.y = 3;a.y = 3; 有一个技巧是把 Proxy 实例作为其他对象的原型对象，这样就可以让其他对象继承（或者说委托？）Proxy 实例的拦截方法。 123456789101112var obj = new Proxy( &#123;&#125;, &#123; get: function() &#123; return 233; &#125; &#125;);var a = Object.create(obj);a.someprop; // 233 此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。 12345678910111213var p = Proxy.revocable( &#123;&#125;, &#123; get() &#123; return 1; &#125; &#125;);var a = p.proxy;a.x; // 1p.revoke();a.x; // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是 Proxy 实例，revoke属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行revoke函数之后，再访问 Proxy 实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 包括 get()、set() 在内，Proxy 支持的拦截操作有十多种，包含了大部分对象的方法操作的拦截。具体请查阅 ECMAScript 6 入门 及 MDN 文档 对象方法原型相关 create,setPrototypeOf,getPrototypeOfObject.create(proto, [ propertiesObject ])该方法使用指定的原型对象和其属性创建了一个新的对象。可理解为该方法会创建一个对象并把这个对象的 [[Prototype]]关联到指定对象。 需要注意的是，Object.create(null)会创建一个拥有空（或者 null）[[Prototype]] 链的对象，这个对象无法进行委托。由于这个对象没有原型链，所以instanceof操作符无法进行判断，因此总是返回 false。这些特殊的空 [[Prototype]] 对象通常被称作“字典”，他们完全不会受到原型链的干扰，因此非常适合用来储存数据。 Object.setPrototypeOf(obj, prototype)该方法是 ES6 的新方法，用于设置一个指定的对象的原型 ( 例如,内置的 [[Prototype]] 属性）到另一个对象或 null。可以代替 ES5 的Object.create。 例如有两个对象 a 和 b，我们需要把 b 设为 a 的原型，以便 a 可以继承 b 的属性： 12345678var a = &#123; x: 1 &#125;;var b = &#123; y: 2 &#125;;Object.setPrototypeOf(a, b);a.x; //1a.y; // 2Object.getOwnPropertyNames(a); // ["x"] 上例中把 b 设为 a 的原型，因此当向 a 查询 y 时，由于 a 本身没有 y 属性，所以会循着原型链查询到 b 的 y。 再例如有两个函数（函数也是对象哦！） Bar 和 Foo，我们需要把 Bar.prototype 关联到 Foo.prototype: 12345678910111213141516171819202122// 创建 Foofunction Foo(name) &#123; this.name = name;&#125;Foo.prototype.sayName = function() &#123; return this.name;&#125;;// 创建 Barfunction Bar(name) &#123; Foo.call(this, name);&#125;//关联 prototype// ES6 之前需要抛弃默认的 Bar.prototypeBar.prototype = Object.create(Foo.prototype);// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype);var a = new Bar("a");a.sayName(); 如果不考虑Object.create(..)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它其实比 ES6 及其之后的方法更短切可读性更高。 Object.getPrototypeOf(obj)该方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。如果没有继承属性，则返回 null 。 1234var a = &#123;&#125;;var b = Object.create(a);Object.getPrototypeOf(b) === a; // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入数组]]></title>
    <url>%2F2018%2F02%2F26%2FJavaScript%E6%B7%B1%E5%85%A5%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组基础简介数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。 属性lengthlength 属性表示数组的长度，即其中元素的个数。JavaScript 数组的 length 属性时可变的，当 length 属性被设置的更大时，整个数组的状态事实上不会发生变化，仅仅是 length 属性变大;当 length 属性被设置的比原来小时，则原先数组中索引大于或等于 length 的元素的值全部被丢失。 prptotype返回对象类型原型的引用。prototype 属性是 object 共有的。一般用来给数组实例添加方法。 constructor表示创建对象的函数。说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。 基本操作创建数组12345678// 数组实例的创建var arr = [];var arr = new Array();var arr = new Array(5); // 创建一个length为5的数组 [undefined, undefined, undefined, undefined, undefined]var arr = new Array(1, 2, 3); // 创建数组并赋值 [1,2,3]var arr = new Array(3).fill(5); // 创建一个length为3的数组，并里面赋值均为5 [5,5,5]var arr = Array.of(7); // 创建数组并赋值[7]var arr = Array.of(1, 2, 4); // 创建数组并赋值 [1,2,4] 检测数组12345678910111213// 判断一个对象是不是一个数组var arr = [];if (arr instanceof Array) &#123;&#125; // 方法1if (Object.prototype.toString.call(arr) == "[object Array]") &#123;&#125; // 方法2if (Array.isArray(arr)) &#123;&#125; // 方法3if (arr.constructor == Array) &#123;&#125; // 方法4 数组方法Array.isArray(obj)检测对象是否 Array,是则范湖 true,否则为 false.Array.from(arrayLike,mapFn,thisArg)该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg 是可选参数，为执行 mapFn 函数时 this 的值。 所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组。 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。 123456789101112131415var arrayLike = &#123; 0: "a", 1: "b", 2: "c", length: 3&#125;;let arrayLike2 = &#123; length: 3 &#125;;let str = "abcd";let newArray = Array.from(arrayLike); // ['a','b','c']let newArray2 = Array.from(arrayLike, i =&gt; &#123; i + "1";&#125;); // ['a1','b1','c1']let newArray3 = Array.from(arrayLike2); // [undefined,undefined,undefined]let newArray4 = Array.from(str); // ['a','b','c','d'] Array.of(item…)该方法用于创建数组实例。该方法用于替代 Array() 或 new Array()。Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。 1234Array.of(7); // [7]Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] 数组实例方法转换方法arr.join(separator)把数组构构造成字符串，它先把数组中的每个元素转换成字符串，然后再用 separator 分隔符把它们链接在一起，separator 分隔符默认是逗号 “,”，要想做到无间隔链接，可以使用空字符串作为 separator： 1234var arr = [1, 2, 3, 4, 5];arr.join("|"); //"1|2|3|4|5"arr.join(""); //12345//另所有对象有具有的 toLocaleString、toString、valueOf，可以看作是join的特殊用法，不常用 栈方法arr.push(item…)将一个或多个新元素添加到数组结尾，并返回数组新长度。arr.pop()移除最后一个元素并返回该元素值。 队列方法arr.unshift(item…)将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度。arr.shift()移除第一个元素并返回该元素值，数组中元素自动前移.如果这个数组是空的，它会返回 undefined。shift 通常比 pop 慢的多。 重排序方法arr.reverse()反转数组的顺序。arr.sort(compareFn)给数组排序，默认升序。 注意： sort 默认会将数组内容视为字符串来排序，所以对数字排序时默认的排序规则会错的离谱。一般我们给 sort 带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数，如果两个参数相等则返回 0，如果第一个参数应该排在前面则返回一个负数，如果第二个参数应该排在前面则返回一个正数： 12345//数组排序var arr = [2, 3, 1, 5, 4];arr.sort(function(a, b) &#123; return a - b;&#125;); // [1,2,3,4,5] 操作方法arr.concat(item…)该方法产生一份 arr 的浅复制，并将多个数组（也可以是字符串，或者是数组和字符串的混合）附加在其后连接为一个数组，返回连接好的新的数组。 arr.slice(start, end)该方法对数组中的一段做浅复制，首先复制数组 arr[start] 至 arr[end] 的部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素（或者理解成 end 的默认值为 arr.length）。字符串也有个同名方法 string.slice。 arr.splice(start, deleteCount, item…)该方法从 arr 中移除一个或多个元素，并将新的 item 插入至移除元素的开始位置， 参数 start 是移除元素的开始位置，deleteCount 是要移除的元素的个数，item 是要被插入的元素。它返回一个包含被移除元素的数组。 arr.copyWithin(target, start, end)该方法复制数组的一部分到同一数组中的另一个位置（会覆盖原成员），并返回修改后的数组。使用这个方法，会修改当前数组。参数 target 为开始替换数据的位置，若 target 大于等于 arr.length，将会不发生拷贝。start 是可选参数，为开始读取数据的位置，默认为 0。end 是可选参数，为停止读取数据的位置，默认为 arr.length。 12[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。 arr.fill(value, start, end)该方法使用给定值填充一个数组，参数 value 是用来填充数组的值。start 是可选参数，为填充开始位置，默认为 0。end 是可选参数，为填充的结束位置，默认为 arr.length。 123[1, 2, 3] .fill(4) // [4, 4, 4] [(1, 2, 3)].fill(4, 1, 2); // [1, 4, 3] fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。 位置方法arr.indexOf(searchElement,start)该方法返回要查找的项在数组中的位置，如果没找到返回 -1。接受两个参数，searchElement 是要查找的项，start 是查找起始位置的索引，默认是 0。 arr.lastIndexOf(searchElement, start)从 start 位置开始向前查找，start 默认值为 arr.length – 1。 注意该方法在比较查找项与数组中每一项时，会使用全等操作符，也就是要求查找的项必须严格相等。 arr.includes(searchElement, fromIndex)该方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。参数 searchElement 为需要查找的元素值。参数 fromIndex 是可选参数，从该索引处开始查找 searchElement，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索，默认为 0。 如果 fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。该方法属于 ES7，但 Babel 转码器已经支持。 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对 NaN 的误判。includes 使用的是不一样的判断算法，就没有这个问题。 12345[NaN] .indexOf(NaN) // -1 [NaN].includes(NaN);// true includes() 方法有意设计为通用方法。它不要求 this 值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。 1234(function() &#123; console.log([].includes.call(arguments, 2)); // true console.log([].includes.call(arguments, 4)); // false&#125;)(1, 2, 3); 迭代方法arr.every(callback,thisArg)对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。callback 被调用时传入三个参数：元素值，元素的索引，原数组。thisArg 为可选参数，指定执行 callback 时使用的 this 值。 arr.some(callback,thisArg)对数组中的每一项运行给定函数，如果该函数对任意一项返回 true,则返回 true。 arr.filter(callback,thisArg)对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 arr.forEach(callback)对数组中的每一项运行给定函数，这个函数没有返回值。本质上和使用 for 一样。 arr.map(callback)对数组中的每一项运行给定的函数，返回每次函数调用后结果组成的数组。 arr.find(callback,thisArg)该方法对数组所有成员依次执行 callback 函数，直到找出第一个返回值为 true 的成员并返回。如果没有，则返回 undefined. 1[1, 2, -5, 19].find((v, i, arr) =&gt; v &lt; 0); // -5 arr.findIndex(callback, thisArg)该方法与 arr.find() 类似，对数组中的成员依次执行 callback 函数，直至找到第一个返回值为 true 的成员，然后返回该成员的索引。如果没有符合条件的成员，则返回 -1。 1[1, 5, 10, 15].findIndex((v, i, arr) =&gt; v &gt; 9); // 2 arr.entries()arr.keys()arr.values()这三个方法都返回一个新的 Array iterator 对象，可以用for...of循环进行遍历，区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 12345678910111213141516171819for (let index of ['a', 'b'].keys()) &#123; console.log(index); &#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem) ;&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b"var arr = ["a", "b";var iterator = arr.entries(); // undefinedconsole.log(iterator); // Array Iterator &#123;&#125;console.log(iterator.next().value); // [0, "a"]console.log(iterator.next().value); // [1, "b"] 归并方法arr.reduce(callback,initialValue)arr.reduceRight(callback,initialValue)这个两个方法都会迭代数组所有的项，然后返回一个最终值。reduce()方法从数组的第一项开始，逐个遍历到最后，而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。它们接受两个参数，callback 每一项上调用的函数，callback 被调用时传入四个参数：上一次调用回调返回的值、正在处理的元素、正在处理的元素的索引值（如果提供了 initialValue ，从 0 开始；否则从 1 开始）、原数组。initialValue 是可选项，作为归并基础的初始值，其值用于第一次调用 callback 的第一个参数。 数组常见问题练习数组合并多个一维数组合并如有两个一维数组，要将他们合并成一个数组: 1234var arr1 = [1, 2];var arr2 = [3, 4];// =&gt; [1,2,3,4] Array.prototype.concat()方法 1var arr = arr1.concat(arr2); //[1, 2, 3, 4] for 循环和 Array.prototype.push() 123456function flation(arr1, arr2) &#123; for (var i = 0; i &lt; arr2.length; i++) &#123; arr1.push(arr2[i]); &#125; return arr1;&#125; reduce()或 reduceRight()方法 12345function flatten(arr1, arr2) &#123; arr2.reduce(function(prev, curr) &#123; return prev.push(curr); &#125;, arr1);&#125; 多维（复合）数组合并成一维数组例如有这么一组多维数组，要把它拍平成 1 维数组： 12345678910var myArray = [ [1, 2], [3, 4, 5], [6, 7, 8, 9], [11, 12, [12, 13, [14]]], 10, 11];// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] Array.prototype.push()方法 123456789101112131415unction flatten(arr, result) &#123; if (!result) &#123; result = [] &#125; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i].constructor == Array) &#123; flatten(arr[i], r) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] Array.prototype.concat()方法 12345678910//省略对二维以上数组的判断function flatten(arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; result = result.concat(arr[i]); &#125; return result;&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9]]); //[1, 2, 3, 4, 5, 6, 7, 8, 9]flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], 10, 11]); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 可以通过 Function.prototype.apply()方法，让其变得更简单: 1234//省略对二维以上数组的判断function flatten(arr) &#123; return Array.prototype.concat.apply([], arr);&#125; 在 ES6 中，还可以这样写： 1234//省略对二维以上数组的判断function flatten(arr) &#123; return [].concat(...arr);&#125; 如果要处理三维或更多维数组，则需要加一些判断： 123456function flatten(arr) &#123; arr = [].concat.apply([], arr); return arr.some(Array.isArray) ? flatten(arr) : arr;&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11, 12, [12, 13, [14]]], 10, 11]);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] 使用 join()和 split()利用数组实例的 join()方法和字符串实例的 split()方法，也可以将多维数组拍平： 12345function flatten(arr) &#123; return arr.join(",").split(",");&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11, 12, [12, 13, [14]]], 10, 11]);//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"] 这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。 数组去重双重循环去重思路： 构建一个空数组来存放去重后的数组 对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比 如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组。 1234567891011121314151617181920function unique(arr) &#123; let result = []; if (arr.length &lt; 2) return; result[0] = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; var repeat = false; for (let j = 0; j &lt; result.length; j++) &#123; if (arr[i] == result[j]) &#123; repeat = true; break; &#125; &#125; if (!repeat) &#123; result.push(arr[i]); &#125; &#125; return result;&#125;unique([1, 2, 3, 4, 3, 2, "a", "b", "a"]);//[1, 2, 3, 4, "a", "b"] 这种方法也可以采用 forEach()方法和 indexOf()方法模拟实现： 123456789function unique(arr) &#123; let result = []; if (arr.length &lt; 2) return; result[0] = arr[0]; arr.forEach(item =&gt; &#123; if (!result.includes(item)) result.push(item); &#125;); return result;&#125; 排序遍历去重思路： 构建一个空数组来存放去重后的数组 用sort()方法对原数组做一个排序，排完序后对数组做遍历，检测数组中第 i 个元素与结果数组中的最后一个元素是否相同，如果不同，则放到结果数组中。 1234567891011function unique() &#123; arr.sort(); var result = []; arr.forEach(item =&gt; &#123; if (item !== result[result.length - 1]) &#123; result.push(item); &#125; &#125;); return result;&#125;unique([1, 2, 3, 4, 3, 2, "a", "b", "a"]); 这种方法有两个特色： 去重后的数组会做排序，主要是因为原数在去重前做了排序 去重后的数组，与数字相同的数字字符无法区分，比如‘1’和 1 对象键值对法思路： 创建一个 js 对象及新数组 遍历原数组，每次取出一个元素与 js 对象的键做对比 如果不包含，将存入对象的元素的值推入到结果数组中，并将 object 对象中该属性名的值设为 1 1234567891011121314function unique(arr) &#123; var result = []; var object = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!object[typeof arr[i] + arr[i]]) &#123; //键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1` result.push(arr[i]); object[typeof arr[i] + arr[i]] = 1; &#125; &#125; return result;&#125;unique([1, 2, 3, 4, 3, 2, "1", "a", "b", "a"]);//[1, 2, 3, 4, "a", "b"] 这种方法比较耗内存，但运行下来耗时最少，是较为优秀的方案。 使用 ES6 的 Set 和 Map 方法12345678910111213// 借助Map数据结构function unique(arr) &#123; const seen = new Map(); return arr.filter(item =&gt; !seen.has(item) &amp;&amp; seen.set(item, 1));&#125;//借助 Set 数据结构function unique(arr) &#123; return Array.from(new Set(arr)); //或 return [...new Set(arr)]&#125;unique([1, 2, 3, 4, 3, 2, "1", "a", "b", "a"]);//[1, 2, 3, 4, "1", "a", "b"] 数组随机排序递归的方法思路:不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。 1234567891011121314function randomSort(arr, newArr = []) &#123; // 如果原数组只有一个值 if (arr.length == 1) &#123; newArr.push(arr[0]); return newArr; // 递归结束 &#125; let random = Math.ceil(Math.random() * arr.length - 1); newArr.push(arr[random]); arr.splice(random, 1); return randomSort(arr, newArr);&#125;randomSort([1, 2, 3, 4, 5, 6, 7]); //[2, 3, 1, 5, 6, 7, 4]randomSort([1, 2, 3, 4, 5, 6, 7]); //[3, 4, 2, 5, 1, 6, 7] 随机交换数组内的元素 (原理 from underscore.js）思路：遍历数组，每次从 i 位置后元素随机挑一个放到 i 位置，将原 i 位置元素放至被挑元素位置 12345678910Array.prototype.shuffle = function() &#123; var len = this.length, arr = this.slice(0), temp, index; for (var i = 0; i &lt; len; i++) &#123; index = i + Math.floor(Math.random() * (len - i)) [arr[i],arr[index]] = [arr[index],arr[i]]; &#125; return arr.slice(0)&#125; 随机从原数组抽取一个元素,加入到新数组思路：遍历数组，每次从数组中随机挑一个元素（随机数最大值为原数组剩余长度），将该元素拿出来放入新数组。 12345678910111213Array.prototype.shuffle = function() &#123; var len = this.length, arr = this.slice(0), result = [], index; for (var i = 0; i &lt; len; i++) &#123; index = Math.floor(Math.random() * (len - i)); result.push(arr.splice(index, 1)[0]); &#125; return result; 1;&#125;[(1, 2, 3, 4, 5, 6, 7)].shuffle();//[5, 3, 2, 1, 7, 4, 6]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之继承的多种方式]]></title>
    <url>%2F2018%2F02%2F26%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型链继承123456789101112131415function Parent() &#123; this.name = "Jay";&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child() &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()); // Jay 存在的问题：1，引用类型的属性被所有的实例共享，eg: 1234567891011121314151617function Parent() &#123; this.names = ["Jhon", "Michel"];&#125;function Child() &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push("Lili");console.log(child1.names); // ["Jhon","Michel","Lili"]var child2 = new Child();console.log(child2.names); // ["Jhon","Michel","Lili"] 2，在创建 Child 的实例时，不能向 Parent 传参 借用构造函数（经典继承）1234567891011121314151617function Parent() &#123; this.names = ["Jhon", "Michel"];&#125;function Child() &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push("Lili");console.log(child1.names); // ["Jhon","Michel","Lili"]var child2 = new Child();console.log(child2.names); // ["Jhon","Michel"] 优点：1，避免了引用类型的属性被所有实例共享。2，可以在 Child 中间向 Parent 传参. eg: 123456789101112131415function Parent(name) &#123; this.name = name;&#125;function Child(name) &#123; Parent.call(this, name);&#125;var child1 = new Child("kaer");console.log(child1.name); // kaervar child2 = new Child("james");console.log(child2.name); // james 缺点：方法都在构造函数里定义，每次创建实例都会创建一遍方法。 组合继承原型链继承和经典继承的组合。 12345678910111213141516171819202122232425function Parent(name) &#123; this.name = name; this.colors = ["red", "cyan"];&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child("xiaoming", 20);child1.colors.push("black");console.log(child1.name, child1.age, child1.colors); // xiaoming 20 ["red", "cyan", "black"]var child2 = new Child("david", 23);console.log(child2.name, child2.age, child2.colors); // david 23 ["red", "cyan"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 原型式继承12345function CreateObj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 上面就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: "kevin", friends: ["daisy", "kelly"]&#125;;var person1 = createObj(person);var person2 = createObj(person);person1.name = "person1";console.log(person2.name); // kevinperson1.firends.push("taylor");console.log(person2.friends); // ["daisy", "kelly", "taylor"] 注意：修改 person1.name 的值，person2.name 的值并未发生改变，并不是因为 person1 和 person2 有独立的 name 值，而是因为 person1.name = ‘person1’，给 person1 添加了 name 值，并非修改了原型上的 name 值. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = object.create(o); clone.sayName = function() &#123; console.log("hi"); &#125;; return clone;&#125; 缺点: 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承组合继承最大的缺点就是虎调用两次父构造函数。一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次是在创建子类型实例的时候： 1var child1 = new Child("david", 23); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为 colors，属性值为[‘red’, ‘blue’, ‘green’]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122function Parent(name) &#123; this.name = name; this.colors = ["red", "cyan"];&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function() &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var Child1 = new Child("david", 23);console.log(child1); 最后封装一下这个函数方法： 1234567891011121314function object(o) &#123; functin F () &#123;&#125; F.prototype = o; return new F();&#125;function prototype (child,parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候prototype(Child,Parent); 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础3]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%803%2F</url>
    <content type="text"><![CDATA[new 关键字如果使用 new 关键字来调用函数式很特别的形式。我们把那些用 new 调用的函数叫做构造函数(constructor function)。 使用了 new 的函数到底做了什么事情呢？ 创建一个新的对象 将对象的 prototype 设置为构造函数的 prototype 执行构造函数，this 执行新构造的对象 返回该对象。如果构造函数返回对象，那么返回该构造对象。 123456// 为了更好地理解底层，我们来定义new关键字function myNew(constructor, ...arguments) &#123; var obj = &#123;&#125;; Object.setPrototypeOf(obj, constructor.prototype); return constructor.apply(obj, arguments) || obj;&#125; 使用 new 和不使用的区别在哪里呢？ 123456789function Bird() &#123; this.wings = 2;&#125;/* 普通的函数调用 */let fakeBird = Bird();console.log(fakeBird); // undefined/* 使用new调用 */let realBird = new Bird();console.log(realBird); // &#123; wings: 2 &#125; 为了便于对比理解，译者额外增加了测试了一种情况： 1234567function MBird() &#123; this.wings = 2; return "hello";&#125;let realMBrid = new MBird();console.log(realMBird); // &#123; wings: 2 &#125; 你会发现，这一句 return “hello”并没有生效！ 原型和继承原型(Prototype)是 JavaScript 中最容易搞混的概念，其中一个原因是 prototype 可以用在两个不同的情形下。 原型关系每一个对象都有一个 prototype 对象，里面包含了所有它的原型的属性。.__proto__是一个不正规的机制(ES6 中提供)，用来获取一个对象的 prototype。你可以理解为它指向对象的 parent。所有普通的对象都继承.constructor 属性，它指向该对象的构造函数。当一个对象通过构造函数实现的时候，__proto__属性指向构造函数的构造函数的.prototype。Object.getPrototypeOf()是 ES5 的标准函数，用来获取一个对象的原型。 原型属性每一个函数都有一个.prototype 属性，它包含了所有可以被继承的属性。该对象默认包含了指向原构造函数的.constructor 属性。每一个使用构造函数创建的对象都有一个构造函数属性。 接下来通过例子来帮助理解： 12345678910111213141516171819202122function Dog(breed, name) &#123; (this.breed = breed), (this.name = name);&#125;Dog.prototype.describe = function() &#123; console.log(`$&#123;this.name&#125; is a $&#123;this.breed&#125;`);&#125;;const rusty = new Dog("Beagle", "Rusty");/* .prototype 属性包含了构造函数以及构造函数中在prototype上定义的属性。*/console.log(Dog.prototype); // &#123; describe: ƒ , constructor: ƒ &#125;/* 使用Dog构造函数构造的对象 */console.log(rusty); // &#123; breed: "Beagle", name: "Rusty" &#125;/* 从构造函数的原型中继承下来的属性或函数 */console.log(rusty.describe()); // "Rusty is a Beagle"/* .__proto__ 属性指向构造函数的.prototype属性 */console.log(rusty.__proto__); // &#123; describe: ƒ , constructor: ƒ &#125;/* .constructor 属性指向构造函数 */console.log(rusty.constructor); // ƒ Dog(breed, name) &#123; ... &#125; 原型链原型链是指对象之间通过 prototype 链接起来，形成一个有向的链条。当访问一个对象的某个属性的时候，JavaScript 引擎会首先查看该对象是否包含该属性。如果没有，就去查找对象的 prototype 中是否包含。以此类推，直到找到该属性或则找到最后一个对象。最后一个对象的 prototype 默认为 null。 拥有 vs 继承一个对象有两种属性，分别是它自身定义的和继承的。 123456789101112131415function Car() &#123;&#125;Car.prototype.wheels = 4;Car.prototype.airbags = 1;var myCar = new Car();myCar.color = "black";/* 原型链中的属性也可以通过in来查看: */console.log("airbags" in myCar); // trueconsole.log(myCar.wheels); // 4console.log(myCar.year); // undefined/* 通过hasOwnProperty来查看是否拥有该属性: */console.log(myCar.hasOwnProperty("airbags")); // false — Inheritedconsole.log(myCar.hasOwnProperty("color")); // true Object.create(obj) 创建一个新的对象，prototype 指向 obj。 123456var dog = &#123; legs: 4 &#125;;var myDog = Object.create(dog);console.log(myDog.hasOwnProperty("legs")); // falseconsole.log(myDog.legs); // 4console.log(myDog.__proto__ === dog); // true 继承是引用传值继承属性都是通过引用的形式。看例子： 1234567891011var objProt = &#123; text: "original" &#125;;var objAttachedToProt = Object.create(objProt);console.log(objAttachedToProt.text); // original// 我们更改objProt的text属性，objAttachedToProt的text属性同样更改了objProt.text = "prototype property changed";console.log(objAttachedToProt.text); // prototype property changed// 但是如果我们讲一个新的对象赋值给objProt，那么objAttachedToProt的text属性不受影响objProt = &#123; text: "replacing property" &#125;;console.log(objAttachedToProt.text); // prototype property changed 异步 JavaScriptJavaScript 是一个单线程程序语言，也就是说 JavaScript 引擎一次只能执行某一段代码。它导致的问题就是：如果有一段代码需要耗费很长的时间执行，其它的操作就被卡住了。JavaScript 使用 Call Stack 来记录函数的调用。一个 Call Stack 可以看成是一摞书。最后一本书放在最上面，也最先被移走。最先放的书在最底层，最后被移走。 为了避免复杂代码占用 CPU 太长时间，一个解法就是定义异步回调函数。我们自己来定义一个异步函数看看： 1234567function greetingAsync(name, callback) &#123; let greeting = "hello, " + name; setTimeout(_ =&gt; callback(greeting), 0);&#125;greetingAsync("fundebug", console.log);console.log("start greeting"); 我们在 greetingAsync 中构造了 greeting 语句，然后通过 setTimeout 定义了异步，callback 函数，是为了让用户自己去定义 greeting 的具体方式。为方便起见，我们时候直接使用 console.log。 上面代码执行首先会打印 start greeting，然后才是 hello, fundebug。也就是说，greetingAsync 的回调函数后执行。在网站开发中，和服务器交互的时候需要不断地发送各种请求，而一个页面可能有几十个请求。如果我们一个一个按照顺序来请求并等待结果，串行的执行会使得网页加载很慢。通过异步的方式，我们可以先发请求，然后在回调中处理请求结果，高效低并发处理。 下面通过一个例子来描述整个执行过程： 123456789101112131415161718const first = function() &#123; console.log("First message");&#125;;const second = function() &#123; console.log("Second message");&#125;;const third = function() &#123; console.log("Third message");&#125;;first();setTimeout(second, 0);third();// 输出:// First message// Third message// Second message 初始状态下，浏览器控制台没有输出，并且事件管理器(Event Manager)是空的； first()被添加到调用栈 将 console.log(“First message”)加到调用栈 console.log(“First message”)执行并输出“First message”到控制台 console.log(“First message”)从调用栈中移除 first()从调用栈中移除 setTimeout(second, 0)加到调用栈 setTimeout(second, 0)执行，0ms 之后，second()被加到回调队列 setTimeout(second, 0)从调用栈中移除 third()加到调用栈 console.log(“Third message”)加到调用栈 console.log(“Third message”)执行并输出“Third message”到控制台 console.log(“Third message”)从调用栈中移除 third()从调用栈中移除 Event Loop 将 second()从回调队列移到调用栈 console.log(“Second message”)加到调用栈 console.log(“Second message”)Second message”到控制台 console.log(“Second message”)从调用栈中移除 Second()从调用栈中移除 特别注意的是：second()函数在 0ms 之后并没有立即执行，你传入到 setTimeout()函数的时间和 second()延迟执行的时间并不一定直接相关。事件管理器等到 setTimeout()设置的时间到期才会将其加入回调队列，而回调队列中它执行的时间和它在队列中的位置以及它前面的函数的执行时间有关。 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础2]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[闭包闭包由一个函数以及该函数定义式所在的环境组成。 12345678910function sayHi(name) &#123; var message = `Hi $&#123;name&#125;`; function greeting() &#123; console.log(message); &#125; return greeting();&#125;var sayHiToJon = sayHi("Jon");console.log(sayHiToJon); // ƒ() &#123; console.log(message) &#125;console.log(sayHiToJon()); // 'Hi Jon!' 请理解var sayHiToJon=sayHi(&#39;Jon&#39;);这段代码的执行过程，sayHi 函数执行，首先将 message 的值计算出来，然后定义了 greeting 函数，函数中引用了 message 变量，最后，返回 greeting 函数。如果按照 C/Java 语言的思路，sayHiToJon 就等价于 greeting 函数，那么就会报错：message 为定义。但是在 JavaScript 中不一样，这里的 sayHiToJon 函数等于 greeting 函数以及一个环境，该环境中包含了 message。因此，当我们调用 sayHiToJon 函数，可以成功将 message 打印出来。因此，这里的闭包就是 greeting 函数和一个包含 message 变量的环境。 闭包的一个优势在于数据隔离，下面用一个例子说明： 12345678910111213141516171819function SpringfieldSchool() &#123; let staff = ["Seymour Skinner", "Edna Krabappel"]; return &#123; getStaff: function() &#123; console.log(staff); &#125;, addStaff: function(name) &#123; staff.push(name); &#125; &#125;;&#125;let elementary = SpringfieldSchool();console.log(elementary); // &#123; getStaff: ƒ, addStaff: ƒ &#125;console.log(staff); // ReferenceError: staff is not defined/* Closure allows access to the staff variable */elementary.getStaff(); // ["Seymour Skinner", "Edna Krabappel"]elementary.addStaff("Otto Mann");elementary.getStaff(); // ["Seymour Skinner", "Edna Krabappel", "Otto Mann"] 在 elementary 被创建的时候，SpringfieldSchool 已经返回。也就是说 staff 无法被外部访问。唯一可以访问的方式就是里面的闭包函数 getStaff 和 addStaff。 我们来看一个面试题：下面的代码有什么问题，如何修复？ 123456const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; setTimeout(function() &#123; console.log(`The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;`); &#125;, (i + 1) * 1000);&#125; 上面的代码输出的结果全部都一样：”The value undefined is at index: 4”。因为所有在 setTimeout 中定义的匿名函数都引用了同一个外部变量 i。当匿名函数执行的时候，i 的值为 4。 这个问题可以改用 IIFE(后面会介绍)方法来解决，通过对每一个匿名函数构建独立的外部作用域来实现。 12345678const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(`The value $&#123;arr[j]&#125; is at index: $&#123;j&#125;`); &#125;, j * 1000); &#125;)(i);&#125; 当然，还有一个方法，使用 let 来声明 i。 123456const arr = [10, 20, 30, 40];for (let i = 0; i &lt; arr.length; i++) &#123; setTimeout(function() &#123; console.log("The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;"); &#125;, i * 1000);&#125; 立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)一个 IIFE 是一个函数表达式在定义之后立即被调用。常用在你想对一个新声明的变量创建一个隔离的作用域。它的格式为:(function(){....})()。前面的大括号用于告诉编译器这里不仅仅是函数定义，后面的大括号用于执行该函数。 12345678910111213141516171819var result = [];for (var i = 0; i &lt; 5; i++) &#123; result.push(function() &#123; return i; &#125;);&#125;console.log(result[1]()); // 5console.log(result[3]()); // 5result = [];for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; var j = i; // copy current value of i result.push(function() &#123; return j; &#125;); &#125;)();&#125;console.log(result[1]()); // 1console.log(result[3]()); // 3 使用 IIFE 可以： 为函数绑定私有数据 创建一个新的环境 避免污染全局命名空间 环境（Context）我们往往容易将环境（Context）和作用域（Scope）搞混，解释一下： 环境（Context）：由函数如何被调用而决定，往往指 this. 作用域（Scope）：可访问的变量。 函数调用：call, apply, bind这三个方法都是为了将 this 绑定到函数，区别在于调用的方式。 .call(a,b,c,d…)会理解执行函数，需要把参数按照顺序传入； .apply([a,b,c,d…])会理解执行函数，需要把参数组合成数组传入了； .call()和.apply()几乎相同。哪个传入参数方便，你就选择哪个。 12345678910const Snow = &#123; surename: "Snow" &#125;;const char = &#123; surename: "Stark", knows: function(arg, name) &#123; console.log(`You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;`); &#125;&#125;;char.knows("something", "Bran"); // You know something, Bran Starkchar.knows.call(Snow, "nothing", "Jon"); // You know nothing, Jon Snowchar.knows.apply(Snow, ["nothing", "Jon"]); // You know nothing, Jon Snow 注意：如果你将数组传入 call 函数，它会认为只有一个参数。 ES6 允许使用新的操作符将数组变换为一个序列。 1char.knows.call(Snow, ...["nothing", "Jon"]); // You know nothing, Jon Snow .bind()返回一个新的函数，以及相应的环境和参数。如果你想该函数稍后调用，那么推荐使用 bind。.bind()函数的优点在于它可以记录一个执行环境，对于异步调用和事件驱动的编程很有用。 .bind()传参数的方式和 call 相同。 123456789const Snow = &#123; surename: "Snow" &#125;;const char = &#123; surename: "Stark", knows: function(arg, name) &#123; console.log(`You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;`); &#125;&#125;;const whoKnowsNothing = char.knows.bind(Snow, "nothing");whoKnowsNothing("Jon"); // You know nothing, Jon Snow this 关键字要理解 JavaScript 中 this 关键字，特别是它指向谁，有时候相当地复杂。this 的值通常由函数的执行环境决定。简单的说，执行环境指函数如何被调用的。this 像是一个占位符(placeholder)，它指向当方法被调用时，调用对应的方法的对象。 下面有序地列出了判断 this 指向的规则。如果第一条匹配，那么就不用去检查第二条了。 new 绑定当使用 new 关键字调用函数的时候，this 指向新构建的对象(实例)。 123456function Person(name,age)&#123; this.name = name; this.age = age; console.log(this);&#125;const = Rachel = new Person('Rachel',30); // &#123;name: 'Rachel',age: 30&#125; 显示绑定(Explicit binding)当使用 call 或则 apply 的时候，我们显示的传入一个对象参数，该参数会绑定到 this。 注意：.bind()函数不一样。用 bind 定义一个新的函数，但是依然绑定到原来的对象。 12345678function fn() &#123; console.log(this);&#125;var agent = &#123; id: "007" &#125;;fn.call(agent); // &#123; id: '007' &#125;fn.apply(agent); // &#123; id: '007' &#125;var boundFn = fn.bind(agent);boundFn(); // &#123; id: '007' &#125; 隐式绑定当一个函数在某个环境下调用(在某个对象里)，this 指向该对象。也就是说该函数是对象的一个方法。 1234567var building = &#123; floors: 5, printThis: function() &#123; console.log(this); &#125;&#125;;building.printThis(); // &#123; floors: 5, printThis: function() &#123;…&#125; &#125; 默认绑定如果上面所有的规则都不满足，那么 this 指向全局对象(在浏览器中，就是 window 对象)。当函数没有绑定到某个对象，而单独定义的时候，该函数默认绑定到全局对象。 1234function printWindow() &#123; console.log(this);&#125;printWindow(); // window object 注意：下面的情况中，inner 函数中的 this 指向全局。 12345678910function Dinosaur(name) &#123; this.name = name; var self = this; inner(); function inner() &#123; alert(this); // window object — the function has overwritten the 'this' context console.log(self); // &#123;name: 'Dino'&#125; — referencing the stored value from the outer context &#125;&#125;var myDinosaur = new Dinosaur("Dino"); 词法(Lexical) this当是使用=&gt;来定义函数时，this 指向定义该函数时候外层的 this。备注：大概是和定义的词法(=&gt;)有关，把它称作 Lexical this。 123456function Cat(name) &#123; this.name = name; console.log(this); // &#123; name: 'Garfield' &#125; (() =&gt; console.log(this))(); // &#123; name: 'Garfield' &#125;&#125;var myCat = new Cat("Garfield"); 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础1]]></title>
    <url>%2F2018%2F02%2F20%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[类型和类型转换在 JavaScript 中有 7 个内置类型：null,undefined,boolean,number,string,object 和 symbol（ES6)。 除了 object 以外，其他都叫做基本类型。 123456typeof 0; //numbertypeof true; // booleantypeof "abc"; // stringtypeof null; // objecttypeof undefined; // undefinedtypeof Symbol("Hi"); // symbol Null vs. Undefined Undefined表示未定义。对于没有初始化的变量，函数调用时未提供的函数参数，不存在的对象属性，它们的默认值就是 undefined。如果一个函数没有返回语句，那么默认的返回值也是 undefined。 Null表示值为空。一个变量我们可以将其赋值为 null,表示当前没有值。 隐式转换 1234var name = "Joey";if (name) &#123; console.log(name + " doesn't share food!"); // Joey doesn’t share food!&#125; 在 if 语句的条件判断中，name 从字符串转换为布尔型。在 if 的代码块中，在控制台将 name 原原本本打印出来。你知道在什么情况下字符串会转换为真，什么时候为假么？ &quot;&quot;，0， null，undefined, NaN, false 会自动转换为false。其它的都会转换为真： 123456Boolean(null); // falseBoolean("hello"); // trueBoolean("0"); // trueBoolean(" "); // trueBoolean([]); // trueBoolean(function() &#123;&#125;); // true 空数组、对象、函数定义都会自动转换为真。 String &amp; Number 之间的转换- 第一个你要非常小心的是+操作符。因为它同时用于数字相加和字符串拼接。 *,/,-只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。 12345678910111 + "2" = "12""" + 1 + 0 = "10""" - 1 + 0 = -1"-9\n" + 5 = "-9\n5""-9\n" - 5 = -14"2" * "3" = 64 + 5 + "px" = "9px""$" + 4 + 5 = "$45""4" - 2 = 2"4px" - 2 = NaNnull + 1 = 1 == vs. === 一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。 实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。 12342 == "2"; // True2 === "2"; // Falseundefined == null; // Trueundefined === null; // False 类型转换有很多取巧的地方，要注意： 1234let a = "0";console.log(Boolean(a)); // Truelet b = false;console.log(Boolean(b)); // False 你认为下面的相等判断会输出什么值呢? 1console.log(a == b); 实际上会返回 true。知道为什么吗？ 如果你将一个布尔类型的和非布尔类型的判断，JavaScript 会将布尔类型的转换为数字然后再比对。执行过程如下： 123"0" == false(1);"0" == 0(2);0 == 0(3); 所以，最终变成了 0==0，当然返回 true 啦。 一些比较容易掉坑的比较，我在这里列出来： 123456789false == ""; // truefalse == []; // truefalse == &#123;&#125;; // false"" == 0; // true"" == []; // true"" == &#123;&#125;; // false0 == []; // true0 == &#123;&#125;; // false0 == null; // false 值 vs. 引用对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string 和 ES6 的 symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。 1234567891011121314var a = 2; // 'a' hold a copy of the value 2.var b = a; // 'b' is always a copy of the value in 'a'b++;console.log(a); // 2console.log(b); // 3var c = [1, 2, 3];var d = c; // 'd' is a reference to the shared valued.push(4); // Mutates the referenced value (object)console.log(c); // [1,2,3,4]console.log(d); // [1,2,3,4]/* Compound values are equal by reference */var e = [1, 2, 3, 4];console.log(c === d); // trueconsole.log(c === e); // false 如果想对复杂类型的值进行值拷贝，你需要自己去对所有子元素进行拷贝。 1234const copy = c.slice(); // 'copy' 即使copy和c相同，但是copy指向新的值console.log(c); // [1,2,3,4]console.log(copy); // [1,2,3,4]console.log(c === copy); // false 作用域（Scope）作用域是程序的执行环境，它包含了在当前位置可访问的变量和函数。 全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window 对象就是全局作用域。 局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。 123456789101112131415function outer() &#123; let a = 1; function inner() &#123; let b = 2; function innermost() &#123; let c = 3; console.log(a, b, c); // 1 2 3 &#125; innermost(); console.log(a, b); // 1 2 — 'c' is not defined &#125; inner(); console.log(a); // 1 — 'b' and 'c' are not defined&#125;outer(); 你可以将作用域想象成一系列不断变小的门。如果一个个子不高的人可以穿过最小的门(局部最小作用域)，那么必然可以穿过任何比它大的门(外部作用域)。 提升(Hoisting)在编译过程中，将 var 和 function 的定义移动到他们作用域最前面的行为叫做提升。 整个函数定义会被提升。所以，你可以在函数还未定义之前调用它，而不用担心找不到该函数。 12345console.log(toSquare(3)); // 9function toSquare(n) &#123; return n * n;&#125; 变量只会被部分提升。而且只有变量的声明会被提升，赋值不会动。 let 和 const 不会被提升。 12345678910111213141516171819202122232425&#123; /* Original code */ console.log(i); // undefined var i = 10; console.log(i); // 10&#125;&#123; /* Compilation phase */ var i; console.log(i); // undefined i = 10; console.log(i); // 10&#125;// ES6 let &amp; const&#123; console.log(i); // ReferenceError: i is not defined const i = 10; console.log(i); // 10&#125;&#123; console.log(i); // ReferenceError: i is not defined let i = 10; console.log(i); // 10&#125; 函数表达式和函数声明 函数表达式 一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。 123var sum = function(a, b) &#123; return a + b;&#125;; 函数声明 函数声明的函数可以在文件中任意位置调用，因为它会被提升。 123function sum(a, b) &#123; return a + b;&#125; 变量：var，let 和 const在 ES6 之前，只能使用 var 来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域 if 和 for 中声明的变量，可以在 if 和 for 的外部被访问。 注意：如果没有使用 var,let 或则 const 关键字声明的变量将会绑定到全局作用域上。 1234567891011function greeting() &#123; console.log(s); // undefined if (true) &#123; var s = "Hi"; undeclaredVar = "I am automatically created in global scope"; &#125; console.log(s); // 'Hi'&#125;console.log(s); // Error — ReferenceError: s is not definedgreeting();console.log(undeclaredVar); // 'I am automatically created in global scope' ES6 的 let 和 const 都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。 12345678910111213let g1 = "global 1";let g2 = "global 2";&#123; /* Creating a new block scope */ g1 = "new global 1"; let g2 = "local global 2"; console.log(g1); // 'new global 1' console.log(g2); // 'local global 2' console.log(g3); // ReferenceError: g3 is not defined let g3 = "I am not hoisted";&#125;console.log(g1); // 'new global 1'console.log(g2); // 'global 2' 一个常见的误解是：使用 const 声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。 12345678910111213const tryMe = "initial assignment";tryMe = "this has been reassigned"; // TypeError: Assignment to constant variable.// You cannot reassign but you can change it…const array = ["Ted", "is", "awesome!"];array[0] = "Barney";array[3] = "Suit up!";console.log(array); // [“Barney”, “is”, “awesome!”, “Suit up!”]const airplane = &#123;&#125;;airplane.wings = 2;airplane.passengers = 200;console.log(airplane); // &#123;passengers: 200, wings: 2&#125; 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之原型和原型链]]></title>
    <url>%2F2018%2F02%2F08%2FJavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &#123;&#125;var person = new Person();person.name = "lili";console.log(person.name); // lili 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 prototype每一个函数都有一个 prototype 属性，就是我们经常在各种例子中看到那个 prototype,比如： 123456789function Person() &#123;&#125;/** *虽然写在注释了，但是要注意：prototype是函数才会有的属性 */Person.prototype.name = "Jay";var person1 = new Person();var person2 = new Person();console.log(person1.name); // jayconsole.log(person2.name); // jay 那这个函数的 prototype 属性到底指向的是什么呢？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？可以这样理解：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。 让我们用一张图表示构造函数和实例原型之间的关系：在这张图中我们用的Object.prototype表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢？ __proto__这是每一个 JavaScript 对象（null 除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下： 123function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 更新关系图：既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 12function Person() &#123;&#125;console.log(Person === Object.prototype.constructor); 再更新关系图：综上所述: 1234567function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // trueconsole.log((Person.prototype.constructor = Person)); // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype); // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子： 12345678910function Person() &#123;&#125;Person.prototype.name = "jay";var person = new Person();person.name = "John";console.log(person.name); // Johndelete person.name;console.log(person.name); // jay 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 John。 但是当我们删除了 person 的 name 属性时，读取 person.name,从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__,也就是 Person.prototype 中查找，幸运的是我们找打 name 属性，结果为 jay。 但是万一没找到呢，原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它： 123var obj = new Object();obj.name = "Kevin";console.log(obj.name); // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的 prototype,所以载更新关系图： 原型链那 Object.prototype 的原型呢？null, 我们可以打印： 1console.log(Object.prototype.__proto__ === null); // true 然而 null 究竟代表了什么呢？ null 代表’没有对象’，即该处不该有值。 所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充constructor首先是 constructor 属性，例子： 123function Person() &#123;&#125;var person = new Person();console.log(person.constructor == Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有这个属性，所以： 1person.constructor = Person.prototype.constructor; __proto__其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的 JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域整理]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是跨域？ 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入 iframe 或是 ajax 应用上带来了不少麻烦。所以我们要通过一些方法使本域的 js 能够操作其他域的页面对象或者使其他域的 js 能操作本域的页面对象（iframe 之间）。 下面是具体的跨域情况详解： 123456789101112131415161718192021222324URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 这里我们需要注意两点: 如果是协议和端口造成的跨域问题“前台”是无能为力的； 在跨域问题上，域仅仅是通过“URL 的首部”来识别而不会去尝试判断相同的 ip 地址对应着两个域或两个域是否在同一个 ip 上。(“URL 的首部”指 window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。) 通过 document.domain 跨域 前面说过了，浏览器有一个同源策略，其限制之一是不能通过 ajax 的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行 js 的交互操作的。不同的框架之间是可以获取 window 对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是www.damonare.cn/a.html ， 在这个页面里面有一个 iframe，它的 src 是damonare.cn/b.html, 很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的： 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('ifame'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把www.damonare.cn/a.html和damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 在页面www.damonare.cn/a.html中设置document.domain: 1234567&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面damonare.cn/b.html中也设置document.domain: 1234&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 通过 location.hash 跨域 因为父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL，URL 有一部分被称为 hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说 HTTP 请求过程中不会携带 hash，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。此方法的原理就是改变 URL 的 hash 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息（由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe），并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，这样做也存在缺点，诸如数据直接暴露在了 url 中，数据容量和类型都有限等。 假如父页面是 baidu.com/a.html,iframe 嵌入的页面为 google.com/b.html（此处省略了域名等 url 属性），要实现此两个页面间的通信可以通过以下方法。1, a.html 传送数据到 b.html a.html 下修改 iframe 的 src 为 google.com/b.html#paco b.html 监听到 url 发生变化，触发相应操作 2, b.html 传送数据到 a.html，由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe b.html 下创建一个隐藏的 iframe，此 iframe 的 src 是 baidu.com 域下的，并挂上要传送的 hash 数据，如 src=”www.baidu.com/proxy.html#…” proxy.html 监听到 url 发生变化，修改 a.html 的 url（因为 a.html 和 proxy.html 同域，所以 proxy.html 可修改 a.html 的 url hash） a.html 监听到 url 发生变化，触发相应操作 b.html 页面的关键代码如下: 123456789try &#123; parent.location.hash = "data";&#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement("iframe"); ifrproxy.style.display = "none"; ifrproxy.src = "http://www.baidu.com/proxy.html#data"; document.body.appendChild(ifrproxy);&#125; proxy.html 页面的关键代码如下 : 12//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 通过 HTML5 的 postMessage 方法跨域 高级浏览器 Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。 比如 damonare.cn 域的 A 页面通过 iframe 嵌入了一个 google.com 域的 B 页面，可以通过以下方法实现 A 和 B 的通信。 A 页面通过 postMessage 方法发送消息： 12345window.onload = function() &#123; var ifr = document.getElementById("ifr"); var targetOrigin = "http://www.google.com"; ifr.contentWindow.postMessage("hello", targetOrigin);&#125;; postMessage 的使用方法： otherWindow.postMessage(message, targetOrigin); otherWindow:指目标窗口，也就是给哪个 window 发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口 message:是要发送的消息，类型为 String、Object(IE8、9 不支持)targetOrigin:是限定消息接收范围，不限制请使用 ‘*’ B 页面通过 message 事件监听并接受消息: 1234567891011121314var onmessage = function(ev) &#123; var data = ev.data; // 消息 var origin = ev.origin; // 消息来源地址 var source = ev.source; // 源window对象 if (origin == "http://www.baidu.com") &#123; console.log(data); // hello &#125;&#125;;if (window.addEventListener != "undefined") &#123; window.addEventListener("message", onmessage, false);&#125; else if (window.attachEvent != "undefined") &#123; // ie window.attachEvent("message", onmessage);&#125; 同理，也可以 B 页面发送消息，然后 A 页面监听并接受消息。 通过 jsonp 跨域 刚才说的这几种都是双向通信的，即两个 iframe，页面与 iframe 或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过 script 标签引入的 js 是不受同源策略的限制的。所以我们可以通过 script 标签引入一个 js 或者是一个其他后缀形式（如 php，jsp 等）的文件，此文件返回一个 js 函数的调用。 比如，有个 a.html 页面，它里面的代码需要利用 ajax 获取一个不同域上的 json 数据，假设这个 json 数据地址是 damonare.cn/data.php, 那么 a.html 中的代码就可以这样： 123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; 我们看到获取数据的地址后面还有一个 callback 参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的 jsonp 地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。 因为是当做一个 js 文件来引入的，所以damonare.cn/data.php返回的必须是一个能执行的 js 文件，所以这个页面的 php 代码可能是这样的(一定要和后端约定好哦): 12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]); 如果你的页面使用 jquery，那么通过它封装的方法就能很方便的来进行 jsonp 操作了。 1234567&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)') &#123; //处理获得的json数据 &#125; );&lt;/script&gt; jquery 会自动生成一个全局函数来替换 callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。\$.getJSON 方法会自动判断是否跨域，不跨域的话，就调用普通的 ajax 方法；跨域的话，则会以异步加载 js 文件的形式来调用 jsonp 的回调函数。 JSONP 的优缺点： JSONP 的优点是：它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。 JSONP 的缺点则是：它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求；它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。 通过 CORS 跨域 CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 平时的 ajax 请求可能是这样的： 123&lt;script type="text/javascript"&gt; var xhr = XMLHttpRequest(); xhr.open('GET','/getSomething',true); xhr.send();&lt;/script&gt; 以上 getSomething 部分是相对路径，如果我们要使用 CORS，相关 Ajax 代码可能如下所示： 1234&lt;script type="text/javascript"&gt; var xhr = XMLHttpRequest(); xhr.open('GET','http://jaybein.site/getSomething',true); xhr.send();&lt;/script&gt; 代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。 服务器端对于 CORS 的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。关于 CORS 更多了解可以看下阮一峰老师的这一篇文章：跨域资源共享 CORS 详解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对缓存的一点理解]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。 缓存的种类很多开发者习惯把 cookie、webStorage 以及 IndexedDB 存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie 的存在更多的是为了让服务端区别用户，webStorage 和 IndexedDB 则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。 实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP 呗。HTTP 协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。 缓存好处有很多： 缓解服务器压力(不用每次去请求资源)； 提升性能(打开本地资源速度当然比请求回来再打开要快得多)； 减少带宽消耗(我相信你可以理解)； 浏览器的缓存策略缓存的目标: 一个检索请求的成功响应: 对于 GET 请求，响应状态码为：200，则表示为成功。一个包含例如 HTML 文档，图片，或者文件的响应； 不变的重定向: 响应状态码：301； 可用缓存响应：响应状态码：304，这个存在疑问，Chrome 会缓存 304 中的缓存设置，Firefox； 错误响应: 响应状态码：404 的一个页面； 不完全的响应: 响应状态码 206，只返回局部的信息； 除了 GET 请求外，如果匹配到作为一个已被定义的 cache 键名的响应； 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢 ❓ 响应头！响应头！响应头！重要的事情说三遍。例如： 1234567Age:23146Cache-Control:max-age=2592000Date:Tue, 28 Nov 2017 12:26:41 GMTETag:W/&quot;5a1cf09a-63c6&quot;Expires:Thu, 28 Dec 2017 05:27:45 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 强缓存阶段以上请求头来自百度首页某个 CSS 文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，Expires是 HTTP/1.0 中的定义缓存的字段，它规定了缓存过期的一个绝对时间。Cache-Control:max-age=2592000是 HTTP/1.1 定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，max-age &gt; Expires。 这就是强缓存阶段，当浏览器再次试图访问这个 CSS 文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️ Firefox 浏览器表现为一个灰色的 200 状态码。 Chrome 浏览器状态码表现为: 1200 (from disk cache)或是200 OK (from memory cache) 多说一点：关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome 会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 协商缓存阶段那么当这个 CSS 文件过期了怎么办?ETag和Last-Modified就该闪亮登场了。 先说Last-Modified，这个字段是文件最后一次修改的时间； ETag呢？ETag是对文件的一个标记，嗯，可以这么说，具体生成方式 HTTP 并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个 CSS 文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码 200 和新的内容，如果没有修改返回状态码 304，浏览器收到 200 状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回 304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome 会为 304 设置缓存，firefox 则不会)😑 具体两个字段携带的内容如下(分别和上面的Last-Modified、ETag携带的值对应)： 12If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMTIf-None-Match: W/&quot;5a1cf09a-63c6&quot; 到这协商缓存结束。 启发式缓存阶段我们把上面的响应头改下： 12345Age:23146Cache-Control: publicDate:Tue, 28 Nov 2017 12:26:41 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带If-Moified-Since呗，不是的，浏览器还有个启发式缓存阶段。 根据响应头中 2 个时间字段Date和Last-Modified之间的时间差值，取其值的 10%作为缓存时间周期。 这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种默认缓存的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。下面用一张图，来解释浏览器整个缓存策略的过程：对于缓存策略介绍到这，接下来再细细分析不同的 HTTP 首部字段的内容，以及它们之间的关系。 传送门]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript:彻底理解同步、异步和事件循环（Event Loop）]]></title>
    <url>%2F2018%2F02%2F06%2FJavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习 JavaScript 的时候了解到 JavaScript 是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下 JavaScript 怎么处理异步问题。 同步与异步在介绍 JavaScript 的异步机制之前，首先介绍一下：什么是同步？什么是异步？ 同步如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 如下所示： 1234//在函数返回时，获得了预期值，即2的平方根Math.sqrt(2);//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'console.log("hello"); 上面两个函数就是同步的。如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。 异步如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 如下所示： 123456789//读取文件fs.readFile("hello.txt", "utf8", function(err, data) &#123; console.log(data);&#125;);//网络请求var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open("GET", url);xhr.send(); // 发起函数 上述示例中读取文件函数 readFile和网络请求的发起函数 send都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在JavaScript中通过回调函数function(err, data) { console.log(data); }和 onreadystatechange，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调。 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。 单线程与多线程在上面介绍异步的过程中就可能会纳闷：既然 JavaScript 是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？ JavaScript 其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS 的运行通常是在浏览器中进行的，具体由 JS 引擎去解析和运行。下面我们来具体了解一下浏览器。 浏览器目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。一个浏览器通常由以下几个常驻的线程： 渲染引擎线程：顾名思义，该线程负责页面的渲染 JS 引擎线程：负责 JS 的解析和执行 定时触发器线程：处理定时事件，比如 setTimeout, setInterval 事件触发线程：处理 DOM 事件 异步 http 请求线程：处理 http 请求 需要注意的是，渲染线程和 JS 引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS 引擎线程会被挂起。因为 JS 可以操作 DOM，若在渲染中 JS 处理了 DOM，浏览器可能就不知所措了。 JS 引擎通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和 JS 引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera 用的是 Webkit 引擎，IE 用的是 Trident 引擎，FireFox 用的是 Gecko 引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。 JS 引擎可以说是 JS 虚拟机，负责 JS 代码的解析和执行。通常包括以下几个步骤： 词法分析：将源代码分解为有意义的分词 语法分析：用语法分析器将分词解析成语法树 代码生成：生成机器能运行的代码 代码执行 不同浏览器的 JS 引擎也各不相同，Chrome 用的是 V8，FireFox 用的是 SpiderMonkey，Safari 用的是 JavaScriptCore，IE 用的是 Chakra。 之所以说 JavaScript 是单线程，就是因为浏览器在运行时只开启了一个 JS 引擎线程来解析和执行 JS。那为什么只有一个引擎呢？如果同时有两个线程去操作 DOM，浏览器是不是又要不知所措了。 所以，虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的。一些 I/O 操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。 消息队列与事件循环通过以上了解，可以知道其实 JavaScript 也是通过 JS 引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到 JS 引擎线程中执行？执行顺序是怎么样的？ 这一切的解释就需要继续了解消息队列和事件循环。 如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。 右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和 setTimeout 中待执行的事件，每个异步任务都和回调函数相关联。 JS 引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。 JS 引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。 上图以 AJAX 异步请求为例，发起异步任务后，由 AJAX 线程执行耗时的异步操作，而 JS 引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在 JS 引擎线程中执行，那么 AJAX 的回调函数就会在某一时刻被调用执行。 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 宏队列和微队列宏队列，macrotask，也叫 tasks。 一些异步任务的回调会依次进入 macro task queue，等待后续被调用，这些异步任务包括： script setTimeout setInterval setImmediate (Node 独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫 jobs。 另一些异步任务的回调会依次进入 micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node 独有) Promise.then() Object.observe(废弃) MutationObserver （注：这里只针对浏览器和 NodeJS） 由此我们得到的执行顺序应该为：script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering 浏览器的 Event Loop 这张图将浏览器的 Event Loop 完整的描述了出来，我来讲执行一个 JavaScript 代码的具体流程： 执行全局 Script 同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如 setTimeout 等）； 全局 Script 代码执行完毕后，调用栈 Stack 会清空； 从微队列 microtask queue 中取出位于队首的回调任务，放入调用栈 Stack 中执行，执行完后 microtask queue 长度减 1； 继续取出位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到直到把 microtask queue 中的所有任务都执行完毕。注意，如果在执行 microtask 的过程中，又产生了 microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； microtask queue 中的所有任务都执行完毕，此时 microtask queue 为空队列，调用栈 Stack 也为空； 取出宏队列 macrotask queue 中位于队首的任务，放入 Stack 中执行； 执行完毕后，调用栈 Stack 为空； 重复第 3-7 个步骤； 重复第 3-7 个步骤； …… 可以看到，这就是浏览器的事件循环 Event Loop 这里归纳 3 个重点： 宏队列 macrotask 一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务； 微任务队列中所有的任务都会被依次取出来执行，直到 microtask queue 为空； 图中没有画 UI rendering 的节点，因为这个是由浏览器自行判断决定的，但是只要执行 UI rendering，它的节点是在执行完所有的 microtask 之后，下一个 macrotask 之前，紧跟着执行 UI render。 示例引用一篇文章中提到的考察 JavaScript 异步机制的面试题来具体介绍。 执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？ 12345678910111213141516171819202122232425setTimeout(function() &#123; for (var i = 0; i &lt; 100000000; i++) &#123;&#125; console.log("timer a");&#125;, 0);for (var j = 0; j &lt; 5; j++) &#123; console.log(j);&#125;setTimeout(function() &#123; console.log("timer b");&#125;, 0);function waitFiveSeconds() &#123; var now = new Date().getTime(); while (new Date().getTime() - now &lt; 5000) &#123;&#125; console.log("finished waiting");&#125;document.addEventListener("click", function() &#123; console.log("click");&#125;);console.log("click begin");waitFiveSeconds(); 要想了解上述代码的输出结果，首先介绍下定时器。 setTimeout的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间。 setTimeout(fn, 0)的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行。看一个例子： 123456setTimeout(function() &#123; console.log("a");&#125;, 0);for (let i = 0; i &lt; 10000; i++) &#123;&#125;console.log("b"); 1b a 打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。 理解了定时器的作用，那么对于输出结果就容易得出了。 首先，先执行同步任务。其中waitFiveSeconds是耗时操作，持续执行长达 5s。 123456701234click beginfinished waiting 然后，在 JS 引擎线程执行的时候，&#39;timer a&#39;对应的定时器产生的回调、 &#39;timer b&#39;对应的定时器产生的回调和两次click对应的回调被先后放入消息队列。由于 JS 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。 1234clickclicktimer atimer b 最后，5s 后的两次click事件被放入消息队列，由于此时 JS 引擎线程空闲，便被立即执行了。 12click;click; 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。举例说明： 1234var button = document.getElement("#btn");button.addEventListener("click", function(e) &#123; console.log("lalla");&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些. 参考文章：JavaScript 运行机制详解：再谈 Event Loop 传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常见的几种轮播]]></title>
    <url>%2F2017%2F08%2F15%2FJavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。 首先奉上轮播图 无缝不停轮播body 布局: 12345678910&lt;div class="container"&gt; &lt;!--将ul和li包住,起显示图片的作用--&gt; &lt;ul&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;li&gt;![](img/img2.png)&lt;/li&gt; &lt;li&gt;![](img/img3.png)&lt;/li&gt; &lt;li&gt;![](img/img4.png)&lt;/li&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css 样式： 12345678910111213141516171819202122232425* &#123; margin: 0; padding: 0;&#125;.container &#123; position: relative; /*给要动的元素也就是ul 它的父级加上相对定位*/ width: 600px; height: 400px; overflow: hidden; /*给要动的元素也就是ul 它的父级加上溢出隐藏*/&#125;.container &gt; ul &#123; position: absolute; /*给要动的元素也就是ul 加上绝对定位,才能保证用left和top;*/ width: 3000px; /*ul 的宽度为 li 的个数 * li 的宽度*/ height: 100%; list-style: none;&#125;.container &gt; ul &gt; li &#123; float: left; width: 600px; height: 100%;&#125;.container &gt; ul &gt; li img &#123; width: 100%; height: 100%;&#125; JS 代码: 12345678910111213var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step() &#123; //设置定时器 if (ul.offsetLeft &lt;= -2400) &#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left = 0 + "px"; &#125; else &#123; var left = ul.offsetLeft - 3; //给ul设置速度 ul.style.left = left + "px"; &#125; var time = 10; //设定一个时间,以控制其轮播的速度 setTimeout(step, time); //定时器内部调用定时器&#125;, 0); 无缝停顿轮播 停顿轮播在不停轮播的基础上加以改进,判断当 ul 走到 li 宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果 ​body 布局以及 css 样式不变 js 代码： 12345678910111213141516171819var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step() &#123; //设置定时器 if (ul.offsetLeft &lt;= -2400) &#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left = 0 + "px"; &#125; else &#123; speed = -3; //给ul设置速度 &#125; var time; if (ul.offsetLeft % 600 == 0) &#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125; else &#123; time = 10; &#125; ul.style.left = ul.offsetLeft + speed + "px"; setTimeout(step, time); //定时器内部调用定时器&#125;, 0); 无缝停顿反向轮播 反向轮播在停顿轮播的基础上加以改进,判断当 ul 最左边和 ul 走到最右边,将速度反向;将最后一张重复的 li 去掉并修改 ul 的宽度 1234567891011121314151617var ul = document.querySelector(".container &gt; ul");var speed = 3;setTimeout(function step() &#123; if (ul.offsetLeft &lt;= -1800 || ul.offsetLeft &gt;= 0) &#123; //判断当ul最左边和ul走到最右边,将速度反向; speed *= -1; &#125; var time = 0; if (ul.offsetLeft % 600 == 0) &#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125; else &#123; time = 10; &#125; ul.style.left = ul.offsetLeft + speed + "px"; setTimeout(step, time); //定时器内部调用定时器&#125;, 0); 透明度普通轮播​1.body 布局上一样;​2.css 样式:将所有 li 绝对定位,重叠在一起​3.JS:先获取到 ul 和 li 并对 li 的数组进行遍历 赋值每个的 opacity​注:要在 js 中遍历 li 再给它赋值 opacity,而不是在 css 中直接设置属性是为了在 js 中好获取到 opacity 并给它进行修改设置 12345678910111213141516171819202122232425262728var ul = document.querySelector(".container &gt; ul"); //获取ulvar lis = document.querySelectorAll(".container &gt; ul &gt;li");var i = 0;for (var i = 0; i &lt; lis.length; i++) &#123; if (i == 0) &#123; //默认显示第一张图,让其透明度为1; lis[i].style.opacity = 1; &#125; else &#123; //其他图片透明度为0; lis[i].style.opacity = 0; &#125;&#125;var i = 0; //重新赋值ivar time = 50; //设置时间,控制图片转换的速度,时间越大,速度越慢setTimeout(function step() &#123; //设置定时器 lis[i % 4].style.opacity -= 0.05; lis[(i + 1) % 4].style.opacity = parseFloat(lis[(i + 1) % 4].style.opacity) + 0.05; if (lis[i % 4].style.opacity == 0) &#123; i++; time = 1000; &#125; else &#123; time = 50; &#125; setTimeout(step, time);&#125;, 0); 透明度指示器轮播body 布局: 123456789101112131415161718192021222324252627&lt;div class="container"&gt; &lt;ul id="picture"&gt; &lt;!--轮播图片区--&gt; &lt;li&gt;![](img/img1.jpg)&lt;/li&gt; &lt;li&gt;![](img/img2.jpg)&lt;/li&gt; &lt;li&gt;![](img/img3.jpg)&lt;/li&gt; &lt;li&gt;![](img/img4.jpg)&lt;/li&gt; &lt;li&gt;![](img/img5.jpg)&lt;/li&gt; &lt;li&gt;![](img/img6.jpg)&lt;/li&gt; &lt;/ul&gt; &lt;ul class="arrow"&gt; &lt;!--左右切换--&gt; &lt;li class="arrowLeft"&gt;&lt;/li&gt; &lt;li class="arrowRight"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="bottom"&gt; &lt;!--指示器--&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li style="margin:0"&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; css 样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990* &#123; margin: 0; padding: 0;&#125;.container &#123; /*整体样式*/ position: relative; width: 600px; height: 400px; overflow: hidden; margin: 20px auto;&#125;.container &gt; .picture &#123; /*轮播图片区样式*/ position: absolute; width: 600px; height: 100%; list-style: none;&#125;.container &gt; .picture &gt; li &#123; position: absolute; width: 600px; height: 100%;&#125;.container &gt; .picture &gt; li img &#123; width: 100%; height: 100%;&#125;.container &gt; .arrow &#123; /*左右切换区样式*/ position: absolute; height: 70px; width: 100%; top: 40%; left: 0; list-style: none;&#125;.container &gt; .arrow &gt; li &#123; width: 40px; height: 70px; padding: 0; margin: 0; cursor: pointer;&#125;.container &gt; .arrow &gt; li:nth-child(1) &#123; float: left; background: url("img/arrow_left1.png");&#125;.container &gt; .arrow &gt; li:nth-child(2) &#123; float: right; background: url("img/arrow_right1.png");&#125;.container &gt; .arrow &gt; li:nth-child(1):hover &#123; background: url("img/arrow_left2.png");&#125;.container &gt; .arrow &gt; li:nth-child(2):hover &#123; background: url("img/arrow_right2.png");&#125;.container .bottom &#123; /*指示器样式*/ position: relative; margin: 0 auto; width: 215px; height: 40px; top: 350px; border-radius: 20px; background-color: grey;&#125;.container &gt; .bottom &gt; ul &#123; position: absolute; height: 30px; width: 205px; bottom: 20px; list-style: none; top: 5px; left: 5px;&#125;.container &gt; .bottom &gt; ul &gt; li &#123; float: left; height: 100%; width: 30px; margin: 0 5px 0 0; padding: 0; border-radius: 50%; background-color: white; font-size: 20px; line-height: 30px; text-align: center; cursor: pointer;&#125; js 代码：​代码分析: 先进行准备工作, 利用 for 循环将初始化的图片透明度已经指示器的背景色设定好 给整个 container 添加事件,当鼠标上来的时候,让自动播放停止 给左,右”按钮” 点击事件,用以切换上一张下一张图片; 给指示器 onmouseenter 事件,使得图片与你的指示器同步,达到随意切换图片的效果; 定义 图片切换的函数 ,使得以上事件都可以调用它 定义自动播放的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var container = document.querySelector(".container");var pictureLis = document.querySelectorAll(".container &gt; .picture &gt; li");var optionLis = document.querySelectorAll(".container &gt; .bottom &gt;ul &gt; li");var arrowLeft = document.querySelector(".container .arrow &gt; .arrowLeft");var arrowRight = document.querySelector(".container .arrow &gt; .arrowRight");var showIndex = 0; //当前正在显示的图片的下标//初始化function init() &#123; for (var j = 0; j &lt; pictureLis.length; j++) &#123; if (j == 0) &#123; optionLis[j].style.backgroundColor = "red"; pictureLis[j].style.opacity = 1; &#125; else &#123; pictureLis[j].style.opacity = 0; &#125; &#125; //给整个container添加事件,当鼠标上来的时候,让自动播放停止 container.onmouseenter = function() &#123; clearTimeout(autoPlayId); &#125;; container.onmouseleave = function() &#123; auto(); &#125;; //给左按钮和右按钮添加点击事件 arrowLeft.onclick = function() &#123; optionLis[showIndex % optionLis.length].style.backgroundColor = "white"; var preIndex = showIndex - 1 + pictureLis.length; move(showIndex, preIndex); showIndex = preIndex; optionLis[showIndex % optionLis.length].style.backgroundColor = "red"; &#125;; arrowRight.onclick = function() &#123; optionLis[showIndex % optionLis.length].style.backgroundColor = "white"; move(showIndex, showIndex + 1); showIndex++; optionLis[showIndex % optionLis.length].style.backgroundColor = "red"; &#125;; //给指示器添加onmouseenter事件,使得图片与指示器同步 for (let i = 0; i &lt; optionLis.length; i++) &#123; optionLis[i].onmouseenter = function() &#123; move(showIndex, i); optionLis[showIndex % optionLis.length].style.backgroundColor = "white"; optionLis[i % optionLis.length].style.backgroundColor = "red"; showIndex = i; &#125;; &#125;&#125;init(); //调用初始化//图片移动function move(showIndex, nextIndex) &#123; setTimeout(function step() &#123; pictureLis[showIndex % pictureLis.length].style.opacity -= 0.05; pictureLis[nextIndex % pictureLis.length].style.opacity = +pictureLis[nextIndex % pictureLis.length].style.opacity + 0.05; if ( pictureLis[showIndex % pictureLis.length].style.opacity &lt;= 0 || pictureLis[nextIndex % pictureLis.length].style.opacity &gt;= 1 ) return; setTimeout(step, 5); &#125;, 0);&#125;//自动播放var autoPlayId; //自动播放定时器idfunction auto() &#123; autoPlayId = setTimeout(function autoStep() &#123; optionLis[showIndex].style.backgroundColor = "white"; move(showIndex, showIndex + 1); //切换下一张图片 showIndex++; if (showIndex == pictureLis.length) showIndex = 0; optionLis[showIndex % optionLis.length].style.backgroundColor = "red"; autoPlayId = setTimeout(autoStep, 2000); &#125;, 2000);&#125;auto();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的10个重点及难点]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%E7%9A%8410%E4%B8%AA%E9%87%8D%E7%82%B9%E5%8F%8A%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[立即执行函数立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作： 1234(function() &#123; // 代码 // ...&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。 闭包对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。 12345678910111213141516function f1() &#123; var N = 0; // N是f1函数的局部变量 function f2() &#123; // f2是f1函数的内部函数，是闭包 N += 1; // 内部函数f2中使用了外部函数f1中的变量N console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为 0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 使用闭包定义私有变量通常，JavaScript 开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量： 1234567891011121314151617function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName("Fundebug");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出Fundebug 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 prototype每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。 1234567891011121314151617function Rectangle(x, y) &#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function() &#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。 模块化JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及Fundebug都是这样实现的。 123456789101112131415161718192021var module = (function() &#123; var N = 5; function print(x) &#123; console.log("The result is: " + x); &#125; function add(a) &#123; var x = a + N; print(x); &#125; return &#123; description: "This is description", add: add &#125;;&#125;)();console.log(module.description); // 输出"this is description"module.add(5); // 输出“The result is: 10” 所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。 变量提升JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。 但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错： 123console.log(y); // 输出undefinedvar y = 2; // 初始化y 上面的代码等价于下面的代码： 12345var y; // 声明yconsole.log(y); // 输出undefinedy = 2; // 初始化y 为了避免 BUG，开发者应该在每个作用域开始时声明变量和函数。 柯里化柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。 12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入 2 个 1 作为参数add(1)(1)，也可以传入 1 个参数之后获取add1与add10函数，这样使用起来非常灵活。 apply, call 与 bind 方法JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。 三者之中，call方法是最简单的，它等价于指定this值调用函数： 1234567891011121314var user = &#123; name: "Rahul Mhatre", whatIsYourName: function() &#123; console.log(this.name); &#125;&#125;;user.whatIsYourName(); // 输出"Rahul Mhatre",var user2 = &#123; name: "Neha Sampat"&#125;;user.whatIsYourName.call(user2); // 输出"Neha Sampat" apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定： apply(thisArg, [argsArray]) call(thisArg, arg1, arg2, …) 12345678910111213var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greet1 = &#123; greet: "Hola"&#125;;user.greetUser.call(greet1, "Rahul"); // 输出"Hola Rahul"user.greetUser.apply(greet1, ["Rahul"]); // 输出"Hola Rahul" 使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回： 123456789101112var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greetHola = user.greetUser.bind(&#123; greet: "Hola" &#125;);var greetBonjour = user.greetUser.bind(&#123; greet: "Bonjour" &#125;);greetHola("Rahul"); // 输出"Hola Rahul"greetBonjour("Rahul"); // 输出"Bonjour Rahul" MemoizationMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。 1234567891011121314151617181920function memoizeFunction(func) &#123; var cache = &#123;&#125;; return function() &#123; var key = arguments[0]; if (cache[key]) &#123; return cache[key]; &#125; else &#123; var val = func.apply(this, arguments); cache[key] = val; return val; &#125; &#125;;&#125;var fibonacci = memoizeFunction(function(n) &#123; return n === 0 || n === 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(100)); // 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000 代码中，第 2 次计算fibonacci(100)则只需要在内存中直接读取结果。 函数重载所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if...else或者switch实现，这就不去管它了。jQuery之父 John Resig 提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。 从效果上来说，people对象的find方法允许 3 种不同的输入: 0 个参数时，返回所有人名；1 个参数时，根据firstName查找人名并返回；2 个参数时，根据完整的名称查找人名并返回。 难点在于，people.find只能绑定一个函数，那它为何可以处理 3 种不同的输入呢？它不可能同时绑定 3 个函数find0,find1与find2啊！这里的关键在于old属性。 由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3 个函数find0,find1与find2就这样通过闭包链接起来了。 根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function addMethod(object, name, f) &#123; var old = object[name]; object[name] = function() &#123; // f.length为函数定义时的参数个数 // arguments.length为函数调用时的参数个数 if (f.length === arguments.length) &#123; return f.apply(this, arguments); &#125; else if (typeof old === "function") &#123; return old.apply(this, arguments); &#125; &#125;;&#125;// 不传参数时，返回所有namefunction find0() &#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName) &#123; var result = []; for (var i = 0; i &lt; this.names.length; i++) &#123; if (this.names[i].indexOf(firstName) === 0) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName) &#123; var result = []; for (var i = 0; i &lt; this.names.length; i++) &#123; if (this.names[i] === firstName + " " + lastName) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;var people = &#123; names: ["Dean Edwards", "Alex Russell", "Dean Tom"]&#125;;addMethod(people, "find", find0);addMethod(people, "find", find1);addMethod(people, "find", find2);console.log(people.find()); // 输出["Dean Edwards", "Alex Russell", "Dean Tom"]console.log(people.find("Dean")); // 输出["Dean Edwards", "Dean Tom"]console.log(people.find("Dean", "Edwards")); // 输出["Dean Edwards"] 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典前端面试题(JavaScript)]]></title>
    <url>%2F2017%2F07%2F12%2F%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript%2F</url>
    <content type="text"><![CDATA[写出简单描述 html 标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的 html 标签去除掉123var reg = /(&lt;\w+&gt;)|(&lt;\/\w+&gt;)/gi;var str = "&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;";alert(str.replace(reg, "")); 编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？123456789101112131415161718192021var str = "asdfssaaasasasasaa";function findMaxAppearChar() &#123; var arr = str.split(""); var obj = &#123;&#125;; var maxKey = ""; var maxIndex = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if (obj[arr[i]]) &#123; obj[arr[i]] += 1; &#125; else &#123; obj[arr[i]] = 1; &#125; &#125; for (key in obj) &#123; if (obj[key] &gt; maxIndex) &#123; maxKey = key; maxIndex = obj[key]; &#125; &#125; return "出现最多字符是" + maxKey + ",一共出现了" + maxIndex + "次";&#125; 闭包是什么? 有什么特性? 对页面有什么影响?(1)闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.(2)闭包有什么特性:通过闭包,可以提供私有作用域.函数执行完后,内部不会释放通过闭包,可以实现带有存储函数运行时变量的函数.(3)对页面有什么影响:大量使用闭包会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 写一个 reverseStr 函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’1234567var str = "12345678";function reverseStr(str) &#123; return str .split("") .reverse() .join("");&#125; 将数字 12345678 转化成 RMB 形式 如： 12,345,678123456789101112function formatNumberToRMB(number) &#123; var str = number + ""; var arr = str.split("").reverse(); //[8,7,6,5,4,3,2,1] var resultArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; resultArr.push(arr[i]); if ((i + 1) % 3 == 0 &amp;&amp; i + 1 != arr.length) &#123; resultArr.push(","); &#125; &#125; return resultArr.reverse().join("");&#125; 请写一个阻止冒泡的兼容函数12345678function stopPropagation(e) &#123; e = window.event ? window.event : e; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125;&#125; 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序123456789function getSortedRandomNumber() &#123; var arr = []; for (var i = 0; i &lt; 10; i++) &#123; arr.push(Math.floor(Math.random() * 90) + 10); &#125; return arr.sort(function(a, b) &#123; return a - b; &#125;);&#125; 有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按 key-value 形式返回到一个 json 结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}123456789101112131415function getQueryJson(URLstr) &#123; var queryIndex = URLstr.indexOf("?") + 1; var queryStr = URLstr.slice(queryIndex); //a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e var arr = queryStr.split("&amp;"); //[ a=1, b=2, c=, d=xxx, e ] var obj = &#123;&#125;; var resultArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; var tempArr = arr[i].split("="); obj[tempArr[0]] = tempArr[1]; &#125; for (var key in obj) &#123; resultArr.push('"' + key + '"' + ":" + '"' + obj[key] + '"'); &#125; return "&#123;" + resultArr.join(",") + "&#125;"; //&#123;"a":"1","b":"2","c":"","d":"xxx","e":"undefined"&#125;&#125; 写一个 function，清除字符串前后的空格。（兼容所有浏览器）12345if (typeof String.prototype.trim !== "function") &#123; String.prototype.trim = function() &#123; return this.replace(/^\s*|\s*$/g, ""); &#125;;&#125; 获取页面所有的 checkbox12345678var resultArr = [];var input = document.querySelectorAll("input");for (var i = 0; i &lt; input.length; i++) &#123; if (input[i].type == "checkbox") &#123; resultArr.push(input[i]); &#125;&#125;//resultArr即中获取到了页面中的所有checkbox 已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成驼峰表示法”getElementById”123456789101112function getCamelCase(str) &#123; var arr = str.split("-"); var resultArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (i === 0) &#123; resultArr.push(arr[i]); &#125; else &#123; resultArr.push(arr[i].charAt(0).toUpperCase() + arr[i].slice(1)); &#125; &#125; return resultArr.join("");&#125; 移动端边框 1 像素问题新项目中 -&gt; viewport + rem 实现 同时通过设置对应 viewport 的 rem 基准值，这种方式就可以像以前一样轻松愉快的写 1px 了。在 devicePixelRatio = 2 时，输出 viewport： 1234&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"/&gt; 在 devicePixelRatio = 3 时，输出 viewport： 1234&lt;meta name="viewport" content="initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no"/&gt; 在旧项目中 -&gt; 伪类 + transform 实现 原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。单条 border 样式设置： 12345678910111213141516.scale-1px &#123; position: relative; border: none;&#125;.scale-1px:after &#123; content: ""; position: absolute; bottom: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125; 四条 boder 样式设置: 1234567891011121314151617181920.scale-1px &#123; position: relative; margin-bottom: 20px; border: none;&#125;.scale-1px:after &#123; content: ""; position: absolute; top: 0; left: 0; border: 1px solid #000; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;&#125; 最好在使用前也判断一下，结合 JS 代码，判断是否 Retina 屏： 123if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) &#123; document.querySelector("ul").className = "scale-1px";&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你走进Gulp]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BGulp%2F</url>
    <content type="text"><![CDATA[Gulp是一款前端自动化构建工具。通俗的来说，就是你本来需要很多条指令才可以完成的事情，通过Gulp你可能只需要一条指令。 Gulp 是什么鬼首先，我很确定它不是鬼。对于之前接触过Webpack的人来说，很大的一个疑惑可能就是：这两者有什么区别？因为Webpack几乎能做全部我们需要做的事情，Gulp存在的意义是什么？我只能说：存在即合理。Gulp貌似是一款取代Grunt的工具，我没有去了解过Grunt，可能是因为没时间，而且好像也不是很有必要。Gulp的核心功能是自动化任务流程，简化操作。比如你需要做打包、编译、压缩、合并等一些乱七八糟的事情，不用Gulp，你可能需要一步一步的“自己”来，而有了Gulp，你预先将这些乱七八糟的事情定义好交给Gulp，然后在特定时刻，Gulp自动将这些事情全都做了。而Webpack的核心功能应该是集中在模块管理上，不过它同样可以通过各种插件，做很多事情。过于纠结这两者的区别也没什么必要。Gulp简单，学起来也就一两天的事。Webpack相对要复杂很多，而且对于新手也有很多坑，但不可忽略它确实很强大。这里的建议是，都学一下，毕竟这是现在最火的两款开发工具。 很重要的几个概念Gulp不算复杂，去官网也就那么一丁点儿的介绍，所以学习之前有必要先知道一些概念。 配置文件（gulpfile.js）Gulp既然是一款工具，就得做一些事情，具体要做些什么，还得由我们来指定。在哪里指定，就是在它的配置文件gulpfile.js中，该文件位于项目的根目录下。以后所有Gulp相关的配置语句都是写在gulpfile.js文件中。 任务（Task）Gulp把需要做的一些事情定义成一个个的任务，每一个任务都有一个名字，然后通过命令调用这个任务的名字，就可以执行该任务对应的代码。如下： 12345678910111213// gulpfile.js 文件中var gulp = require("gulp");// style 任务gulp.task("style", function() &#123; // 一些要做的事情&#125;);// build 任务gulp.task("build", function() &#123; // 要做的事情&#125;); 插件前面定义的都是一些空任务，啥也不会做。因为Gulp本身不会做任何“事情”，它只负责把那些要做的事情准备（分类、串联）好。具体谁来做，那就是插件。 Gulp有很多插件，几乎能满足你的各种需求。我想对于初学者来说有个疑问：我怎么知道我需要的插件叫什么？那么，我在这里先列出一些插件。我也不知道这些是不是常用的插件，不过看起来好像比较常用。*gulp-connect：可以跑一个本地服务器，貌似现在应该不会有人直接将 index.html 拖到浏览器来调试吧； gulp-concat：看清了，这是 concat，用来合并文件的； gulp-clean：删除文件用的； gulp-rename：重命名文件； gulp-minify-html：压缩 html 用的； gulp-inject：可以将 css 样式和 js 脚本文件插入到 html 文件中； gulp-minify-css：压缩 css； gulp-uglify：压缩 js； gulp-imagemin：压缩图片； gulp-postcss：自动添加 css 中的前缀，很实用的家伙。 就这些吧，看清楚长啥样就好了。正如你看到的那样，Gulp所有的插件都是以gulp-开头。对于那些有点经验的人来说，要什么插件可能一般都是直接去npm或github上搜索。对于不知道怎么搜的（一般都是不知道关键词），就老老实实百度吧。一个很好的习惯就是平时多记录和总结，因为很多插件在不同的工具和平台中，叫法基本上都是一样的。另外，这里还给一个官方收录的插件列表。 具体使用方法Gulp的安装就不说了，需要的直接看看这里。先举一个栗子（玩玩）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 引入gulp，无需解释var gulp = require('gulp');// 引入插件var connect = require('gulp-connect')， sass = require('gulp-sass')， uglify = require('gulp-uglify');// 定义任务gulp.task('server', function () &#123; // 使用 connect 插件创建一个服务器 connect.server(&#123; // 这里是传入的一些配置项 root: 'dist', livereload: true &#125;)&#125;);gulp.task('style', function () &#123; // 匹配资源文件 gulp.src('./src/**/*.scss') // 对匹配到的 文件 传到一个插件中 .pipe(sass(&#123; // 用sass插件处理 匹配到的文件 // 插件的配置项 outputStyle: 'compressed' // 插件的功能 打印错误信息 &#125;).on('error', sass.logError)) // 串联 将sass处理后的文件 传送到下一个插件中 // 将文件 输出到指定目录下 .pipe(gulp.dest('dist')) // 重新加载 服务器 .pipe(connect.reload());&#125;);gulp.task('script', function () &#123; gulp.src('./src/**/*.js') .pipe(uglify()) .pipe(gulp.dest('dist')) .pipe(connect.reload());&#125;);// 默认任务 要等到数组中的任务执行完之后 才执行gulp.task('default', ['style', 'script', 'server'], function () &#123; // 监听 匹配到的文件是否改变 // 一旦变化就执行 数组 中的任务 gulp.watch('./src/js/*.js', ['script']); gulp.watch('./src/css/*.scss', ['style']);&#125;); Gulp的基本使用大概就这些，gulpfile.js文件大概就是这个样子的。对于该配置文件，命令行只需执行一条语句： 1gulp 没错，就这样！该指令会自动执行默认的任务。如果要指定具体的任务，后面直接跟上任务名即可，比如： 1gulp server 如何使用插件一般典型的用法就是直接将插件传入.pipe函数中，插件的配置项通过一个对象传入插件中： 1.pipe(uglify()) 一般若没有特殊要求，可以省略配置项。gulp.src()和.pipe()都会返回一个叫Vinyl files的stream（我也不知道是个什么鬼），所以这些方法是可以串联起来的。 谈几个 API这里列出一些比较常用的 API 接口，详细用法请参阅官方文档 gulp.src：匹配文件用的； gulp.dest：输出文件到指定目录； gulp.task：定义一个任务； gulp.watch：监听文件，改动触发。 好像就这四个？我也是刚发现，还说列几个常用的。所以学起来还是很容易的，不过要全部学通，可能也要花一点时间。反正我是没有认真把官网的文档看完，尽管它一点也不长。我的想法是，掌握基本的使用方法和思想，有实际需求的时候再去参考官方文档。（关键是我现在没这反面的需求啊） 文件匹配原则好像这家伙不是按照常规的正则去匹配的，官方给出了一个参考，有兴趣的自己看看，反正我没看。直接举几个栗子吧： *：能匹配abc.js，a.css，不能匹配a/bc.js； **：能匹配a.js，a/b/cd/d.css； *.*：能匹配aaa.js，b.css； a/**/*.js：能匹配a/b/c/d/ef.js，a/b/c.js。 还要说明一点，语句gulp.dest(&#39;dist&#39;)中的dist表示在项目根目录下生成dist目录。输出的文件路径是*号匹配到的文件名（未被修改的情况下），上面例子中输出的目录结构是这样的： 12345678910111213// 假设原文件路径- src - css - a.scss - js - b.js// 输出的文件路径- dist - css - a.css - js - b.js 默认情况下，dist只会替换*号之前的路径，当然也可以自己修改，具体自行参阅官方文档 传送门]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印样式CSS的技巧和要点]]></title>
    <url>%2F2017%2F07%2F09%2F%E6%89%93%E5%8D%B0%E6%A0%B7%E5%BC%8FCSS%E7%9A%84%E6%8A%80%E5%B7%A7%E5%92%8C%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不经过任何处理而直接打印网站上的页面会得到一个不理想的效果。 我们 WEB 开发人员可以简单采用几个要点来使之达到较为合适的效果： 使用响应式布局设置打印的效果 在合适的时候打印背景图片和颜色 添加显示的网址或页面链接，以供参考 使用 css filter 提高打印的图形效果 针对打印的样式，而不是屏幕显示样式首先，我们需要使用媒体查询（media query）针对打印样式设置。 123@media print &#123; // write some styles&#125; 重新针对打印写 CSS 样式是没有必要的，我们只需要针对差异设置打印的样式覆盖掉之前的默认样式。 大多数的浏览器会自动根据打印更改颜色，以节省打印原料，但是我们还是尽可能的手工设置一下。 为了达到最佳效果，使颜色清晰明了，我们至少需要包含一下基本的打印样式。 123456@media print &#123; body &#123; color: #000; background: #fff; &#125;&#125; 对于打印，大多数情况下我们不需要打印整个页面，只需要打印一个简洁的能够突出需要信息的页面，那么我们将不相关的部分隐藏掉（如：导航条、背景图片）。 123456789101112131415161718/* Default styles */h1 &#123; color: #fff; background: url(banner.jpg);&#125;@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125;&#125; 在编写打印样式表的时候，你要注意要使用厘米(cm),英寸(inch)或者磅(pt)作为单位而不是屏幕像素单位，实际的单位对打印非常有用。 为了保证打印样式有用，写 CSS 样式使打印的内容距离纸张边缘，看起来更好，需要使用 @page 这个语法： 12345678910111213141516171819202122@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125; body, article &#123; width: 100%; margin: 0; padding: 0; &#125; @page &#123; margin: 2cm; &#125;&#125; 为了保证不被跨页打印，如一个标题和内容在页面底部被分开： 1234h2,h3 &#123; page-break-after: avoid;&#125; 另一种情况是要防止图片过宽而超出纸张边缘： 123img &#123; max-width: 100% !important;&#125; 第三个要点是确保 articles 文章标签的内容，在新的一页开始： 123article &#123; page-break-before: always;&#125; 最后，还要注意列表和图片不被分开在不同的页： 1234ul,img &#123; page-break-inside: avoid;&#125; 背景图片和颜色对于一些网站，颜色和背景图还是非常必要需要遵循的。如果用户是在 webkit 内核浏览器上打印的话，我们可以强制打印机打印屏幕上所看到的颜色（即强制在打印页面上出现任何的背景图和颜色），一般来说彩色打印机可以做到这点，我们需要一个单独的媒体查询： 123456@media print and (color) &#123; * &#123; -webkit-print-color-adjust: exact; print-color-adjust: exact; &#125;&#125; 遗憾的是，这不能马上应用于 firefox opera 和 IE. 传送门~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你豁然开朗的AJAX和JSONP]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AE%A9%E4%BD%A0%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97%E7%9A%84AJAX%E5%92%8CJSONP%2F</url>
    <content type="text"><![CDATA[先说说 JSONP 是怎么产生的：1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web 页面上调用 js 文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有 src 这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）； 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进 js 格式的文件里，供客户端调用和进一步处理； 4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP 的客户端具体实现：1.我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。假设远程服务器上有一个remote.js文件，可以使用以下方式调用： 12//remote.jsalert("我是远程文件"); 12345678910//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script src="remote.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行以后可以看到一个弹出框：我是远程文件，说明跨域调用成功。 2.现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。 123456789101112131415161718//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script type="text/javascript"&gt; let localHandler = function(data) &#123; alert( "我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：" + data.result ); &#125;; &lt;/script&gt; &lt;script src="remote.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 12//remote.jslocalHandler(&#123; result: "我是远程js带来的数据" &#125;); 运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp 的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用 XXX 函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。 1234567891011121314151617181920//jsonp.html&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;html lang="en"&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 let flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 '+data.price + ' 元，'+'余票 ' + data.tickets + ' 张。'); &#125;;// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）let url = "flightResult.aspx?code=CA1998&amp;callback=flightHandler";// 创建script标签，设置其属性let script = document.createElement('script');script.setAttribute('src', url); // 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是 CA1998 次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.js的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 1flightHandler(&#123; code: "CA1998", price: 1780, tickets: 5 &#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;title&gt;Untitled Page&lt;/title&gt;&lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "remote.js?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？ 补充： 这里针对ajax与jsonp的异同再做一些补充说明：1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的 js 脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性]]></title>
    <url>%2F2017%2F06%2F28%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ES6 简介​ 历时将近 6 年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​ 由于 ES6 是在 2015 年发布的，所以也叫 ES2015。​ 以后 ESCMAScript 标准一年一更新，统一使用年份命名：ES2016、ES2017、…. 块级作用域 在 ES5 之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6 新增了块级作用域，补足了这方面的缺陷。 块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建： 函数内部 在代码块（即 { }）内部 let 声明 使用 let 声明变量的语法和使用 var 声明的语法是一样的。但是 let 声明的变量的作用域会限制在当前的代码块中。这是 let 与 var 的最大区别。 1234567let a = 10;if (a &gt; 5) &#123; console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错） let b = 20; console.log(b);&#125;console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错） 注意： 1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问 2.用 let 声明的变量也没有声明提前这一特性。 3.在同一个块中，let 声明的变量也不能重复声明。 4.在声明变量的时候尽量使用 let，慢慢的抛弃 var const 声明(Constant Declarations) 在 ES6 使用 const 来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const 声明的常量和 let 变量一样也是具有块级作用域的特性。 123456var a = 20;if (true) &#123; const b = 20; b = 30; //错误! 常量不能重新赋值 const c; //错误！ 常量声明的同时必须赋值。&#125; 注意:1.const 的特性除了声明的是常量为，其他与 let 一样。 2.在 let 和 const 声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。 3.使用 let 和 const 声明的变量和常量不再是 window 的属性。 也就是说通过 window.a 是无法访问到的。 循环中的块级绑定 使用 var 声明的循环变量在循环结束后仍然可以访问到。 使用 let 声明的循环变量，在循环结束之后会立即销毁。 12345for (let i = 0; i &lt; 3; i++) &#123; // 循环结束之后会立即销毁 i console.log(i);&#125;console.log(i); //此处无法访问到 i 。 循环中的函数 看下面的代码，是输出 10 个 10，而不是 0，1，2，… 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 输出 "10" 共10次&#125;); 解决办法需要使用函数的自执行特性。 12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function(value) &#123; return function() &#123; console.log(value); &#125;; &#125;)(i) );&#125;funcs.forEach(function(func) &#123; func(); // 输出 0，1，2 ... 9&#125;); 如果使用 let 声明变量，则完全可以避免前面的问题。 这是 ES6 规范中专门定义的特性。在 for … in 和 for … of 循环中也适用 123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 输出 0，1，2 ... 9&#125;); 说明：let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。 函数的新增特性带默认参数的函数 JavaScript 函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。 1234function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;;&#125; 其实上面的默认值方法有个 bug：当 timeout 是 0 的时候也会当做假值来处理，从而给赋值默认值 2000. ES6 从语言层面面上增加了默认值的支持。看下面的代码： 1234//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 其余代码&#125; 默认参数对 arguments 对象的影响 在非严格模式下，arguments 总是能反映出命名参数的变化。看下面的代码： 12345678910function foo(a, b) &#123; //非严格模式 console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true&#125;foo(1, 2); 在 ES5 的严格模式下，arguments 只反映参数的初始值，而不再反映命名参数的变化！ 1234567891011function foo(a, b) &#123; //严格模式 "use strict"; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 修改a的值不会影响到arguments[0]的值 console.log(arguments[1] === b); //false&#125;foo(1, 2); 当使用 ES6 参数默认值的时候，不管是否是在严格模式下，都和 ES5 的严格模式相同。看下面的代码： 123456789function foo(a, b = 30) &#123; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。 console.log(arguments[1] === b); //false。 b使用了默认值，所以表现的和严格模式一样。&#125;foo(1, 2); 注意：如果这样调用 foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给 arguments 参数。 默认参数表达式 (Default Parameter Expressions) 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码 1234567891011function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。 return first + second;&#125;console.log(add(1, 1)); // 2. 调用add函数的时候，传入了第二个参数，则以传入的参数为准。console.log(add(1)); // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。 有一点需要要注意：getValue()只会在调用 add 且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。 1234function add(first, second = first) &#123; // 使用第一个参数作为第二个参数的默认值 return first + second;&#125; 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的 let 和 const 的暂存性死区一个意思。 未命名参数问题 Javascript 并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在 ES5 之前，我们一般可以通过 arguments 对象来获取到未命名参数的值。但是罗显繁琐。 12345function foo(a) &#123; console.log(a); console.log(arguments[1]); //取得传入的多余的参数。&#125;foo(2, 3); ES6，提供了一种更加优雅处理未命名参数的问题：剩余参数( Rest Parameters)语法：function a(a, … b){ }剩余参数使用三个点( … )和变量名来表示。 12345function foo(a, ...b) &#123; console.log(a); console.log(b instanceof Array); //true .多余的参数都被放入了b中。b其实就是一个数组。&#125;foo(2, 3, 4, 6); 注意：1.函数最多只能有一个剩余参数 b。而且这个剩余参数必须位于参数列表的最后位置。 2.虽然有了剩余参数，但是 arguments 仍然存在，但是 arguments 完全无视了剩余参数的存在。 3.剩余参数是在函数声明的时候出现的。 函数中的扩展运算符 例如:Math 中的 max 函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用 apply 方法。 看下面的代码： 12let values = [25, 50, 75, 100];console.log(Math.max.apply(Math, values)); // 100 上面这种方法虽然可行，但是总是不是那么直观使用 ES6 提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。 123let values = [25, 50, 75, 100];console.log(Math.max(...values)); //使用扩展运算符。相当于拆解了数组了。console.log(Math.max(...values, 200)); //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。 注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。 全新的函数：箭头函数（=&gt;）箭头函数语法 基本语法如下： 123形参列表 =&gt; &#123; //函数体&#125;; 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。 123456789var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;;console.log(sum(3, 4));//前面的箭头函数等同于下面的传统函数var add = function(num1, num2) &#123; return num1 + num2;&#125;;console.log(add(2, 4)); 如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有 return，return 关键字也可以省略。如果函数体内有多条语句，则 {} 不能省略。 1234567891011var sum = (num1, num2) =&gt; num1 + num2;console.log(sum(5, 4));//前面的箭头函数等同于下面的传统函数var add = function(num1, num2) &#123; return num1 + num2;&#125;;console.log(add(2, 4));//如果这一行代码是没有返回值的，则方法的返回自也是undefinedvar foo = (num1, num2) =&gt; console.log("aaa");console.log(foo(3, 4)); //这个地方的返回值就是undefined 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略 12var foo = a =&gt; a + 3; //因为只有一个参数，所以()可以省略console.log(foo(4)); // 7 如果想直接返回一个 js 对象，而且还不想添加传统的大括号和 return，则必须给整个对象添加一个小括号 () 123456789var foo = () =&gt; (&#123; name: "lisi", age: 30 &#125;);console.log(foo());//等同于下面的；var foo1 = () =&gt; &#123; return &#123; name: "lisi", age: 30 &#125;;&#125;; 使用箭头函数实现函数自执行1234567var person = (name =&gt; &#123; return &#123; name: name, age: 30 &#125;;&#125;)("zs");console.log(person); 箭头函数中无 this 绑定(No this Binding) 在 ES5 之前 this 的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为 this 的绑定和定义位置无关，只和调用方式有关。在箭头函数中则没有这样的问题，在箭头函数中，this 和定义时的作用域相关，不用考虑调用方式箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。 123456789101112131415var PageHandler = &#123; id: "123456", init: function() &#123; document.addEventListener( "click", event =&gt; this.doSomething(event.type), false ); // 在此处this的和init函数内的this相同。 &#125;, doSomething: function(type) &#123; console.log("Handling " + type + " for " + this.id); &#125;&#125;;PageHandler.init(); 看下面的一段代码： 12345var p = &#123; foo: () =&gt; console.log(this) //此处this为window&#125;;p.foo(); //输出为 window对象。 并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。 说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用 new 的方式来使用箭头函数。 2.由于箭头函数中的 this 与函数的作用域相关，所以不能使用 call、apply、bind 来重新绑定 this。但是虽然 this 不能重新绑定，但是还是可以使用 call 和 apply 方法去执行箭头函数的。 无 arguments 绑定 虽然箭头函数没有自己的 arguments 对象，但是在箭头函数内部还是可以使用它外部函数的 arguments 对象的。 123456function foo() &#123; //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。 return () =&gt; arguments[0]; //箭头函数的返回值是foo函数的第一个参数&#125;var arrow = foo(4, 5);console.log(arrow()); // 4 对象功能的扩展 在 JavaScript 中，几乎所有的类型都是对象，所以使用好对象，对提示 JavaScript 的性能很重要。 对象类别 ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括： 普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。 特异对象（exotic object）的某些内部行为和默认的有所差异。 标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。 内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。 对象字面量的语法扩展简写的属性初始化12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name: name, age: age &#125;;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; ES6 中，上面的写法可以简化成如下形式： 12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name, //当对象属性名和本地变量名相同时，可以省略冒号和值 age &#125;;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; 当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。 简写的方法声明1234567var person = &#123; name: "lisi", sayHell: function() &#123; console.log("我的名字是：" + this.name); &#125;&#125;;person.sayHell(); 在 ES6 中，上面的写法可以简化成如下的形式： 1234567var person = &#123; name: "李四", sayHell() &#123; console.log("我的名字是：" + this.name); &#125;&#125;;person.sayHell(); 在字面量中动态计算属性名 在 ES5 之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。 123456var p = &#123; name: "李四", age: 20&#125;;var attName = "name";console.log(p[attName]); //这里 attName表示的是一个变量名。 而下面的方式使用时没有办法访问到 attName 这个变量的。 123456var attName = "name";var p = &#123; attName: "李四", // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。 age: 20&#125;;console.log(p[attName]); // undefined 在 ES6 中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。 123456var attName = "name";var p = &#123; [attName]: "李四", // 引用了变量attName。相当于添加了一个属性名为name的属性 age: 20&#125;;console.log(p[attName]); // 李四 新增的方法 ECMAScript 从第五版开始避免在 Object.prototype 上添加新的全局函数或方法，转而去考虑具体的对象类型（如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。ES6 在全局 Object 上添加了几个新的方法来轻松地完成一些特定任务。 Object.is() 在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示： 123456789101112console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == "5"); // trueconsole.log(5 === "5"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, "5")); // false 很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。 Object.assign() 使用 assign 主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。assing 可以把一个对象的属性和访问完整的转 copy 到另外一个对象中。 123456789101112var p = &#123; name: "lisi", age: 20, friends: ["张三", "李四"]&#125;;var p1 = &#123;&#125;;Object.assign(p1, p); //则p1中就有了与p相同的属性和方法. p1是接受者，p是提供者console.log(p1);//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）console.log(p1.friends == p.friends); //true p1和p的friends同事指向了同一个数组。p.friends.push("王五");console.log(p1.friends); //['张三', '李四', '王五'] assign 方法可以接受任意多的提供者。意味着后面提供者的同名属性会覆盖前面提供者的属性值。 1234567891011var p = &#123; name: "lisi", age: 20, friends: ["张三", "李四"]&#125;;var p1 = &#123; name: "zs"&#125;;var p2 = &#123;&#125;;Object.assign(p2, p, p1); //p和p1都是提供者console.log(p2.name); // zs 字符串功能的增强查找子字符串 在以前在字符串中查找字符串的时候，都是使用 indexOf 方法。ES6 新增了三个方法来查找字符串。 includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。 startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。 endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。 每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示： 12345678910111213var msg = "Hello world!";console.log(msg.startsWith("Hello")); // trueconsole.log(msg.endsWith("!")); // trueconsole.log(msg.includes("o")); // trueconsole.log(msg.startsWith("o")); // falseconsole.log(msg.endsWith("world!")); // trueconsole.log(msg.includes("x")); // falseconsole.log(msg.startsWith("o", 4)); // trueconsole.log(msg.endsWith("o", 8)); // trueconsole.log(msg.includes("o", 8)); // false repeat 方法 ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如： 123console.log("x".repeat(3)); // "xxx"console.log("hello".repeat(2)); // "hellohello"console.log("abc".repeat(4)); // "abcabcabcabc" 字符串模板字面量 模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应： 多行字符串 针对多行字符串的形式概念（formal concept）。 基本的字符串格式化 将字符串中的变量置换为值的能力。 转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。 模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。 基本语法 使用一对反引号 ``(tab 正上方的按键)来表示模板字面量。 12345let message = `Hello world!`; //使用模板字面量创建了一个字符串console.log(message); // "Hello world!"console.log(typeof message); // "string"console.log(message.length); // 12 多行字符串 在 ES5 之前 JavaScript 是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是 bug 的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \） 1234var s = "abc \aaaaaa";console.log(s); //但是输出的结果中不包括换行 但是在 ES6 中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法. 12345var s = `abcaaaaadsalfjadfadfja`;console.log(s); 但是要注意： 反引号中的所有空格和缩进都是有效字符。 字符串置换 置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。语法：\${变量名、表达式、任意运算、方法调用等}可以嵌入任何有效的 JavaScript 代码 123var name = "李四";var msg = `欢迎你$&#123;name&#125;同学`;console.log(msg); 模板标签什么是模板标签 模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示： 1let message = myTag`Hello world`; 在上面的代码中，myTag 就是模板标签。myTag 其实是一个函数，这个函数会被调用来处理这个模板字符串。 定义模板标签 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下： 12345678910111213141516171819let name = "张三", age = 20, message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;/* 应该定义一个函数show： 参数1：一个字符串数组。在本例中包含三个元素。 0:"我来给大家介绍" 1:"的年龄是" 2:"." 参数2和参数3：表示需要置换的字符串的值。 */function show(stringArr, value1, value2) &#123; console.log(stringArr); // console.log(value1); // 张三 console.log(value2); // 20 return "abc";&#125;console.log(message); //abc 为了简化书写，一般把 Value1 和 Value2 写成剩余字符串的形式 123function show(stringArr, ...values) &#123; // blabla...&#125; 解构解构的实用性 在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如： 123456789let options = &#123; repeat: true, save: false&#125;;// 从对象中提取数据let repeat = options.repeat, save = options.save; 这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。 这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。 对象解构对象解构的基本形式 对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。 123456789let node = &#123; type: "Identifier", name: "foo"&#125;;//这里就相当于声明了两个变量： type = node.type; name:node.namelet &#123; type, name &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo" 在上面的结构中必须要初始化。否则会出现语法错误。 12345678// 语法错误！var &#123; type, name &#125;;// 语法错误！let &#123; type, name &#125;;// 语法错误！const &#123; type, name &#125;; 解构赋值表达式 如果声明的变量想改变他们的值，也可以使用解构表达式。 123456789101112let node = &#123; type: "Identifier", name: "foo" &#125;, type = "Literal", name = 5;//注意：此处必须要在圆括号内才能使用解构表达式(&#123; type, name &#125; = node);console.log(type); // "Identifier"console.log(name); // "foo"" 对象解构时的默认值 如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined 12345678910let node = &#123; type: "Identifier", name: "foo"&#125;;//因为node中没有叫value的属性，所以valued的值将会是undefinedlet &#123; type, name, value &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // undefined 不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像） 12345678910let node = &#123; type: "Identifier", name: "foo"&#125;;//手动添加value的默认值为3let &#123; type, name, value = 3 &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // 3 赋值给不同的变量名 在前面的操作中，都是把对象的属性值，赋值给同名变量。其实也可以赋值给不同名的变量。 123456789let node = &#123; type: "Identifier", name: "foo"&#125;;// localType才是要定义的新的变量。 type是node的属性let &#123; type: localType, name: localName &#125; = node;console.log(localType); // "Identifier"console.log(localName); // "foo" 数组解构数组解构基本语法 数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如： 12345let colors = ["red", "green", "blue"];let [firstColor, secondColor] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 如果只想取数组中的某一项，则可以不用命名。 12345let colors = ["red", "green", "blue"];//只取数组中的第三项。let [, , thirdColor] = colors;console.log(thirdColor); // "blue" 解构表达式 你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如： 12345678let colors = ["red", "green", "blue"], firstColor = "black", secondColor = "purple";[firstColor, secondColor] = colors; //可以不用加括号。当然添加也不犯法console.log(firstColor); // "red"console.log(secondColor); // "green" 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码： 12345678let a = 3, b = 4, temp;temp = a;a = b;b = temp;console.log(a);console.log(b); 那么在 ES6 中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式 123456let a = 3, b = 4;//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。[a, b] = [b, a];console.log(a);console.log(b); 新的基本类型：Symbol 以前我们有 5 种基本数据类型：Number、String、Boolean、Null、UndefinedES6 新增了一种新的数据类型：Symbol在 ES5 之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。 创建 Symbol Symbol 在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是 Symbol 却不可以使用字面量的是形式去创建。我们可以使用 symbol 全局函数来创建 Symbol。 12345let firstName = Symbol(); //创建一个Symbollet person = &#123;&#125;;person[firstName] = "张三";console.log(person[firstName]); // "张三" 说明：上面的代码中，firstName 作为 symbol 类型被创建并赋值给 person 对象以作其属性。每次访问这个属性时必须使用该 symbol。 在创建 Symbol 的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。 123var s1 = Symbol("abc");var s2 = Symbol("abc");console.log(s1 == s2); //false 注意：任意两个 Symbol 都不会相等，即使创建他们的时候使用了相同的参数。 识别 Symbol 既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如： 12let symbol = Symbol();console.log(typeof symbol); // "symbol" Symbol 作为属性名​ 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 12345678var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = "Hello!";// 第二种写法var a = &#123; [mySymbol]: "Hello!"&#125;; 注意：1,symbol 作为对象的属性的时候，只能使用[ ]去访问，不能使用点去访问。2,symbol 作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用 for… in 和 for…of 时无法遍历到这个 symbol 属性的。 Symbol 属性名的遍历​ Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。 123456789var obj = &#123;&#125;;var a = Symbol("a");var b = Symbol("b");obj[a] = "Hello";obj[b] = "World";// 返回obj对象所有Symbol类型的属性名组成的数组。var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols); //[Symbol(a), Symbol(b)] 看下面代码 12345678var obj = &#123;&#125;;var foo = Symbol("foo");obj[foo] = "lisi";for (var i in obj) &#123; console.log(i); // 无输出 。 因为遍历不到Symbol型的属性&#125;Object.getOwnPropertyNames(obj); // [] 只能拿到非Symbol类型的属性Object.getOwnPropertySymbols(obj); //[Symbol(foo)] 还有一个新 API 可以拿到所有类型的属性，包括常规和 Symbol 型的。Reflect.ownKeys() 123456let obj = &#123; [Symbol("my_key")]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj); // ["enum", "nonEnum", Symbol(my_key)] 说明：由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for(字符串)和 Symbol.keyFor(symbol 类型的值) Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的 Symbol 值，如果搜到则返回这个 symbol，如果搜不到则创建一个 Symbol，并把它注册在全局环境中。 12345//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册var a = Symbol.for("foo");//第二次搜到上次创建的var b = Symbol.for("foo");console.log(a === b); //因为两次搜到的是同一个Symbol，所以此处是true Symbol.for()和 Symbol()都可以创建 Symbol 类型的数据。二者区别：1，Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。2，Symbol()则不会有搜索的过程，每次都是一个全新的不同的 symbol，而且也不会向全局环境中注册。 123var a = Symbol("foo");var b = Symbol.for("foo");console.log(a == b); //false Symbol.keyFor(symbol):返回一个已经注册的 symbol 的”key”。 1234var a = Symbol("foo");var b = Symbol.for("foo");console.log(Symbol.keyFor(a)); // undefined. 因为a没有想全局环境中登记，所以是undefindedconsole.log(Symbol.keyFor(b)); // foo Set 数据结构​JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。 ​ 因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。 Set 是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set 中的元素不能重复，而数组中的元素可以重复。 一句话总结：Set 类型是一个包含无重复元素的有序列表 创建 Set 和并添加元素 Set 本身是一个构造函数。 12345678//创建Set数据结构对象。var s = new Set();//调用set对象的add方法，向set中添加元素s.add("a");s.add("c");s.add("b");//set的size属性可以获取set中元素的个数console.log(s.size); Set 中不能添加重复元素123456var s = new Set();s.add("a");s.add("c");s.add("b");s.add("a"); //重复，所以添加失败。注意这个地方并不会保存。console.log(s.size); // 长度是3 看下面代码： 1234var s = new Set();s.add(5);s.add("5");console.log(s.size); // 长度是2 在上面的代码中，数字 5 和字符串 5 都会添加成功。为什么呢？ Set 是使用什么机制来判断两个元素是否相等的呢？是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。回忆一下：这个方法除了 +0 和-0、NaN 和 NaN 认为相等，其余和三个 === 是完全一样的。 12345678910var s = new Set();s.add(+0);s.add(-0); //重复添加不进去s.add(NaN);s.add(NaN); //重复添加不进去s.add([]);s.add([]); //两个空数组不相等，所以可以添加进去s.add(&#123;&#125;);s.add(&#123;&#125;); // 两个空对象也不重复，所以也可以添加进去console.log(s.size); // 长度是6 使用数组初始化 Set123//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。var s = new Set([2, 3, 2, 2, 4]);console.log(s.size); 判断一个值是否在 Set 中 使用 Set 的 has() 方法可以判断一个值是否在这个 set 中。 123456let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueconsole.log(set.has(6)); // false 移除 Set 中的元素 delete(要删除的值) ：删除单个值clear()：清空所有的值 123456789101112131415let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueset.delete(5);console.log(set.has(5)); // falseconsole.log(set.size); // 1set.clear();console.log(set.has("5")); // falseconsole.log(set.size); // 0 遍历 Set 数组有个方法 forEach 可以遍历数组。Set 也有 forEach 可以遍历 Set。使用 Set 的 forEach 遍历时的回调函数有三个参数：function (value, key, ownerSet){ }参数 1：遍历到的元素的值参数 2：对 set 集合来说，参数 2 的值和参数 1 的值是完全一样的。参数 3：这个 set 自己 1234let set = new Set(["a", "c", "b", 9]);set.forEach(function(v, k, s) &#123; console.log(v + " " + (v === k) + " " + (s === set)); // 永远是true&#125;); 将 Set 转换为数组 将数组转换为 Set 相当容易，你只需要在创建 Set 集合时把数组作为参数传递进去即可。把 Set 转换为数组使用前面讲到的扩展运算符也很容易 123let set = new Set([1, 2, 3, 3, 3, 4, 5]), arr = [...set]; //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响console.log(arr); // [1,2,3,4,5] 这种情况在需要去数组中重复元素的时候非常好用。 1234567function eliminateDuplicates(items) &#123; return [...new Set(items)];&#125;let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1], //返回的是新的没有重复元素的数组。 noDuplicates = eliminateDuplicates(numbers);console.log(noDuplicates); // [1,2,3,4,5] Set 提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map. Map 数据结构​ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。 ​ 键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。 ​ 这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。 创建 Map 对象和 Map 的基本的存取操作 Map 创建也是使用 Map 构造函数向 Map 存储键值对使用 set(key, value);方法可以使用 get(key),来获取指定 key 对应的 value 12345678var map = new Map();map.set("a", "lisi");map.set("b", "zhangsan");map.set("b", "zhangsan222"); // 第二次添加，新的value会替换掉旧的console.log(map.get("a"));console.log(map.get("b")); //zhangsan222console.log(map.get("c")); //undefined.如果key不存在，则返回undefinedconsole.log(map.size); //2 Map 与 Set 类似的 3 个方法 has(key) - 判断给定的 key 是否在 map 中存在 delete(key) - 移除 map 中的 key 及对应的值 clear() - 移除 map 中所有的键值对 初始化 Map 创建 Map 的时候也可以像 Set 一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。也就是传入的实际是一个二维数组！ 123456789//map接受一个二维数组var map = new Map([ //每一个数组中，第一个是map的key，第二个是map的value。如果只有第一个，则值是undefined ["name", "lisi"], ["age", 20], ["sex", "nan"]]);console.log(map.size);console.log(map.get("name")); Map 的 forEach 方法1234567891011var map = new Map([["name", "李四"], ["age", 20], ["sex", "nan"]]);/* 回调函数有三个参数： 参数1：键值对的value 参数2：键值对的key 参数3：map对象本身 */map.forEach(function(value, key, ownMap) &#123; console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`); console.log(this);&#125;); 迭代器和 for…of 循环循环问题12345var colors = ["red", "green", "blue"];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。迭代器就是为了解决这个问题的。 什么是迭代器​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。 ​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。 我们可以使用 ES5 知识创建一个迭代器 1234567891011121314151617181920212223function createIterator(items) &#123; var i = 0; return &#123; next: function() &#123; var done = i &gt;= items.length; var value = !done ? items[i++] : undefined; return &#123; done: done, value: value &#125;; &#125; &#125;;&#125;//创建一个可以在指定数组上面迭代的迭代器对象。var iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// for all further callsconsole.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。 生成器函数 生成器函数就是返回迭代器的函数！生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。看下面代码： 123456789101112//生成器函数。 注意中间的 * 不能丢function* createIterator() &#123; //每个yield的后面的值表示我们迭代到的值。 yield也定义了我们迭代的顺序。 yield 3; yield 4; yield 2;&#125;var it = createIterator();console.log(it.next().value); // 3console.log(it.next().value); // 4console.log(it.next().value); // 2console.log(it.next().value); //undefined 迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。每调用一次迭代器的 next 方法，如果碰到 yield 都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用 next 方法，会从上次停止的地方继续执行。 1234567891011121314151617//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。function* createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125; yield items[i]; &#125;&#125;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。 生成器函数表达式 你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如： 123456789101112131415let createIterator = function*(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：无法使用箭头函数来创建生成器。 可迭代类型和 for-of 迭代循环 迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。 ​ 与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。​ 该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。​ 换句话说，默认情况下只有 数组、set、Map 和字符串才可以使用迭代器去迭代。 (也就可以使用 for…of 了)​for…of 循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！ 使用 for…of 迭代数组： 1234var arr = ["a", "c", "b", "d"];for (var item of arr) &#123; console.log(item);&#125; 使用 for…of 迭代 Set: 1234var set = new Set(["a", "c", "b", "d"]);for (var item of set) &#123; console.log(item);&#125; 使用 for…of 迭代 Map： 12345var map = new Map([["name", "lisi"], ["sex", "男"], ["age", 20]]);map.set("aaa", "bbb");for (var item of map) &#123; console.log(item); //注意：这里迭代到的是由key和value组成的数组。&#125; 使用 for … of 迭代字符串 1234var s = "abcd";for (let c of s) &#123; console.log(c);&#125; 注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用 for…of 会抛出异常。 说明：以数组为例。 ​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。 ​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。 访问可迭代类型的默认迭代器 Symbol.iterator 是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。 123let s = "abcd";let it = s[Symbol.iterator](); //调用字符串的Symbol.iterator方法console.log(it.next()); //返回迭代器迭代到的第一个对象 因为 Symbol 可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === "function";&#125;console.log(isIterable([1, 2, 3])); // trueconsole.log(isIterable("Hello")); // trueconsole.log(isIterable(new Map())); // trueconsole.log(isIterable(new Set())); // trueconsole.log(isIterable(&#123; name: "李四" &#125;)); // false。普通对象不可迭代 自定义可迭代类型 开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如： 12345678910111213141516let collection = &#123; items: [], *[Symbol.iterator]() &#123; for (let item of this.items) &#123; yield item; &#125; &#125;&#125;;collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125; 类 和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。 ES5 之前的模拟的类​ 在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如： 12345678910111213function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true 说明：前面的 PersonType 我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。 ES6 中基本的类声明 在 ES6 直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。 1234567891011121314151617181920//class关键字必须是小写。 后面就是跟的类名class PersonClass &#123; // 等效于 PersonType 构造函数。 constructor(name) &#123; //这个表示类的构造函数。constuctor也是关键字必须小写。 this.name = name; //创建属性。 也叫当前类型的自有属性。 &#125; // 等效于 PersonType.prototype.sayName. 这里的sayName使用了我们前面的简写的方式。 sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // "function"console.log(typeof PersonClass.prototype.sayName); // "function" 说明：1，自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。2，类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。 虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记:1，类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。2，类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。3，所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。4，所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。5，不使用 new 来调用类构造函数会抛出错误。也就是 必须使用 new 类() 的方式使用6，试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的） 匿名类表达式 函数有函数表达式，类也有类表达式。类表达式的功能和前面的类的声明是一样的。 123456789101112let PersonClass = class &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas" 具名类表达式1234567891011let PersonClass = class PersonClass2 &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;; 注意：具名类表达式中 PersonClass2 这个类名只能在类的内部访问到，在外面是访问不到的. 作为一等公民的类型 在 JavaScript 中，函数是作为一等公民存在的。(也叫一等函数)。类也是一等公民。 类可以作为参数传递 12345678910111213function createObject(classDef) &#123; return new classDef();&#125;let obj = createObject( class &#123; sayHi() &#123; console.log("Hi!"); &#125; &#125;);obj.sayHi(); // "Hi!" 立即调用类构造函数，创建单例 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;("Nicholas");person.sayName(); // "Nicholas" 动态计算类成员的命名 类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算) 123456789101112let methodName = "sayName";class PersonClass &#123; constructor(name) &#123; this.name = name; &#125; [methodName]() &#123; console.log(this.name); &#125;&#125;let me = new PersonClass("Nicholas");me.sayName(); // "Nicholas" 静态成员 在 ES5 中，我们可以直接给构造函数添加属性或方法来模拟静态成员。 123456789101112function PersonType(name) &#123; this.name = name;&#125;// 静态方法。 直接添加到构造方法上。 (其实是把构造函数当做一个普通的对象来用。)PersonType.create = function(name) &#123; return new PersonType(name);&#125;;// 实例方法PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create("Nicholas"); 在上面的 create 方法在其他语言中一般都是作为静态方法来使用的。ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的： 123456789101112131415161718class PersonClass &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125; // 等效于 PersonType.create。 static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create("Nicholas"); 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！ ES6 中的继承 在 ES6 之前要完成继承，需要写很多的代码。看下面的继承的例子： 1234567891011121314151617181920function Father(name) &#123; this.name = name;&#125;Father.prototype.sayName = function() &#123; console.log(this.name);&#125;;function Son(name, age) &#123; Father.call(this, name); this.age = age;&#125;Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function() &#123; console.log(this.age);&#125;;var son1 = new Son("儿子", 20);son1.sayAge(); //20son1.sayName(); //儿子 继承的基本写法 如果在 ES6 通过类的方式完成继承就简单了很多。需要用到一个新的关键字：extends 12345678910111213141516171819202122232425class Father &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Son extends Father &#123; //extents后面跟表示要继承的类型 constructor(name, age) &#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge() &#123; console.log(this.age); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName();console.log(son1 instanceof Son); // trueconsole.log(son1 instanceof Father); //true 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。关于 super 的使用，有几点需要注意：1，你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。2，你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说 super()必须放在构造函数的首行。3，在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。 在子类中屏蔽父类的方法 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 ) 12345678910111213141516171819202122232425262728class Father &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Son extends Father &#123; //extents后面跟表示要继承的类型 constructor(name, age) &#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge() &#123; console.log(this.age); &#125; //子类中的方法会屏蔽到父类中的同名方法。 sayName() &#123; super.syaName(); //调用被覆盖的父类中的方法。 console.log("我是子类的方法，我屏蔽了父类：" + name); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName(); 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过 super.方法()来完成。注意：1，如果是调用构造方法，则 super 不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法2，普通方法调用需要使用 super.父类的方法() 来调用。 静态方法也可以继承1234567class Father &#123; static foo() &#123; console.log("我是父类的静态方法"); &#125;&#125;class Son extends Father &#123;&#125;Son.foo(); //子类也继承了父类的静态方法。 这种方式调用和直接通过父类名调用时一样的。 Moudle JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。 什么是模块​ 模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义： 模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。 模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。 模块顶级作用域中的 this 为 undefined 。 模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。 模块必须输出可被模块外部代码使用的相关内容。 一个模块可以引入另外的模块。 导出模块​ 可以使用 export 关键字来对外暴露模块中的部分代码。​ 一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们 123456789101112131415161718192021222324252627282930// 输出变量export var color = "red";export let name = "Nicholas";export const magicNumber = 7;// 输出函数export function sum(num1, num2) &#123; return num1 + num1;&#125;// 输出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 该函数没有使用export关键字 所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到function subtract(num1, num2) &#123; return num1 - num2;&#125;// 定义一个函数...function multiply(num1, num2) &#123; return num1 * num2;&#125;// 可以把这个函数的引用导出。 和导出函数是一样的。export &#123; multiply &#125;; 引入模块 一旦有了导出内容的模块，则可以在另一个模块中使用 import 关键字来获取他们。 1import &#123; identifier1, identifier2 &#125; from "./a.js"; ​ import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）。浏览器中的 &lt;script&gt;元素也使用了这个路径形式，意味着它必须包含文件扩展名。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript特效三大系列总结]]></title>
    <url>%2F2017%2F06%2F20%2FJavaScript%E7%89%B9%E6%95%88%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天主要是讲 js 的 DOM 元素的位置关系的三大系列：offset 系列，scroll 系列，client 系列。希望你看完之后能更加了解，熟练应用。let’s go~ offset 系列offset 系列的 5 个属性123456789101112131415161. offsetLeft : 用于获取元素到最近的定位父盒子的左侧距离 * 计算方式: 当前元素的左边框的左侧到定位父盒子的左边框右侧 * 如果父级盒子没有定位, 那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的left值2. offsetTop : 用于获取元素到最近定位父盒子的顶部距离 * 计算方式:当前元素的上边框的上侧到定位父盒子的上边框下侧 * 如果父级盒子没有定位,那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的top值3. offsetWidth :用于获取元素的真实宽度(除了margin以外的宽度)4. offsetHeight : 用于获取元素的真实高度(除了margin以外的高度)5. offsetParent :用于获取该元素中有定位的最近父级元素 * 如果当前元素的父级元素都没有进行定位,那么offsetParent为body 与 style.(left/top/width/height)的区别:1231. offset系列的是只读属性,而通过style的方式可以读写2. offset系列返回的数值类型(结果四舍五入),style返回的是字符串3. offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style不可以 scroll 系列scroll 系列的 4 个属性1234567891. scrollHeight :元素中内容的实际高度(没有边框) * 如果内容不足,就是元素的高度2. scrollWidth: 元素中内容的实际宽度(没有边框) * 如果内容不足,就是元素的宽度3. scrollTop: onscroll事件发生时,元素向上卷曲出去的距离4. scrollLeft : onscroll事件发生时,元素向左卷曲出去的距离 兼容问题123456789101112131415161718192021222324* 未声明 DTD: 谷歌,火狐,IE9+支持 document.body.scrollTop/scrollLeft* 已经声明DTD:IE8以下支持 document.documentElement.scrollTop/scrollLeft* 火狐/谷歌/ie9+以上支持的 window.pageYOffest/pageXOffest// 兼容处理的代码function getScroll() &#123; return &#123; left: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0, top: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0 &#125;;&#125;// 使用方法:1. 取得scrollLeft值: getScroll().left2. 取得scrollTop值: getScroll().top client 系列client 系列的 4 个常用属性12345671. clientWidth : 获取网页可视区域的宽度2. clientHeight: 获取网页可视区域的高度3. clientX :获取鼠标事件发生时的应用客户端区域的水平坐标4. clientY :获取鼠标事件发生时的应用客户端区域的垂直坐标 兼容问题clientWidth 和 clientHeight 的兼容问题123456789101112131415161718192021222324252627282930313233343536//由浏览器对象不同导致* 未声明 DTD: 谷歌,火狐,IE9+支持document.body.clientWidth/clientHeight* 已经声明DTD:IE8以下支持document.documentElement.clientWidth/clientHeight* 火狐/谷歌/ie9+以上支持的 window.innerWidth/innerHeight// 兼容处理的代码function client()&#123; if(window.innerWidth)&#123; return &#123; "width":window.innerWidth, "height":window.innerHeight &#125;; &#125;else if(document.compatMode === "CSS1Compat")&#123; return &#123; "width":document.documentElement.clientWidth, "height":document.documentElement.clientHeight &#125;; &#125;else&#123; return &#123; "width":document.body.clientWidth, "height":document.body.clientHeight &#125;; &#125;&#125;// 使用方法:1. 取得clientWidth的值: client().width2. 取得clientHeight的值: client().height clientX 和 clientY 的兼容问题1234567891011121314151617181920212223242526272829//由事件参数对象的兼容性问题导致1. 谷歌,火狐,IE9+: 事件参数对象随着事件处理函数的参数传入2. IE8以下: event对象必须作为window对象的一个属性(window.event)// 兼容处理的代码//将client和scroll的兼容问题进行对象的封装var evtTools=&#123; //获取兼容的事件参数对象 getEvt:function (e) &#123; return window.event?window.event:e; &#125;, //获取的是可视区域的横坐标 getClientX:function (e) &#123; return this.getEvt(e).clientX; &#125;, //获取的是可视区域的纵坐标 getClientY:function (e) &#123; return this.getEvt(e).clientY; &#125;, //获取向左卷曲出去的距离的横坐标 getScrollLeft:function () &#123; return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, //获取向上卷曲出去的距离的纵坐标 getScrollTop:function () &#123; return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;&#125;; 总结1234567891011121314网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js图片懒加载及优化]]></title>
    <url>%2F2017%2F06%2F18%2Fjs%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为啥要用图片懒加载对页面加载速度影响最大的就是图片，一张普通的图片可以达到几 M 的大小，而代码也许就只有几十 KB。当页面图片很多时，页面的加载速度缓慢，几 S 钟内页面没有加载完成，也许会失去很多的用户。所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理将页面中的 img 标签 src 指向一张小图片或者 src 为空，然后定义 data-src（这个属性可以自定义命名，我才用 data-src）属性指向真实的图片。src 指向一张默认的图片，否则当 src 为空时也会向服务器发送一次请求（指向默认的一张图那就只需请求一次）。可以指向 loading 的地址。 当载入页面时，先把可视区域内的 img 标签的 data-src 属性值负给 src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 注：图片要指定宽高。关于窗口各种宽度，可以看下面两篇文章：scrollWidth,clientWidth,offsetWidth 的区别JS 中关于 clientWidth offsetWidth scrollWidth 等的含义 图片懒加载的实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt="" /&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt="" /&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt="" /&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt="" /&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt="" /&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt="" /&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt="" /&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt="" /&gt; &lt;script&gt; (function() &#123; let num = document.getElementsByTagName("img").length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; &#125;)(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用节流函数进行优化如果直接将函数绑定在 scroll 事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 同时还有以下场景往往由于事件频繁被触发，因而频繁执行 DOM 操作、资源加载等重行为，导致 UI 停顿甚至浏览器崩溃。1.window 对象的 resize、scroll 事件 2.拖拽时的 mousemove 事件 3.射击游戏中的 mousedown、keydown 事件 4.文字输入、自动完成的 keyup 事件解决这个问题的方法有去抖动和节流的方法 去抖动原理： 当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间。 不足:当我一直滚动鼠标的时候，lazyload 函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了 节流原理：预设一个执行周期，如果这个周期结束了都还没触发函数，那就会执行一次函数；如果这个周期还没结束就触发了函数，那定时器将重置，开始新周期。 达到了想要的效果，既没有频繁的执行也没有延迟执行 运用节流函数的图片懒加载代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt="" /&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt="" /&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt="" /&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt="" /&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt="" /&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt="" /&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt="" /&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt="" /&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt="" /&gt; &lt;script&gt; (function() &#123; let num = document.getElementsByTagName("img").length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; // 采用了节流函数 function throttle(fun, delay, time) &#123; let timeout, startTime = new Date(); return function() &#123; let context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;; &#125; window.addEventListener("scroll", throttle(lazyload, 500, 1000)); &#125;)(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>image-lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JavaScript之DOM操作]]></title>
    <url>%2F2017%2F06%2F11%2F%E5%8E%9F%E7%94%9FJavaScript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[直接获取元素1234document.getElementById(selector); // 获取指定id的元素document.getElementsByClassName(selector); // 获取指定class的元素的集合document.getElementsByTagName(selector); // 获取指定标签名的元素集合document.getElementsByName(selector); // 获取带有指定名称（name属性）的元素集合 获取父子兄弟元素123456789101112el.parentNode; // 获取直接父元素el.offsetParent; // 用于计算定位的父元素(position属性为relative、absolute或fixed的最近的父元素),若不存在这样的父元素，则为body，但是在低版本IE中可能为htmlel.childNodes; // 所有子节点的集合，包含文本节点(换行或空白)el.children; // 所有子元素的集合，不包含文本节点el.firstChild;el.lastChild;el.nextSibling;el.previousSibling; // 以上四个获取的节点，都包含文本节点el.firstElementChild;el.lastElementChild;el.nextElementSibling;el.previousElementSibling; // 以上四个获取的节点，不包含文本节点，但是在低版本IE里不兼容 增删改元素12345678let element = document.createElement(TagName); // 根据标签名创建标签let textnode = document.createTextNode(content); // 根据内容创建文本节点el.appendChild(element); // 将element标签添加为el的子节点，并且位于最后el.insertBefore(element, child); // 将element标签添加为el的子节点，并且位于child之前，child参数为空则与appendChild方法效果一致el.removeChild(element); // 删除el的子节点el.replaceChild(new, old); // 用new替换old，new可以为新创建的节点也可以为已存在的节点el.hasChildNode(); // 判断节点是否包含子节点，包含返回true，不包含返回false.el.cloneChild(true/false); // 默认为false，只复制当前节点，为true时它的所有子节点也一起复制。它也是存在内存中，也需要向页面里添加。 操作元素属性12345678let attr = document.createAttribute(name); // 创建一个属性节点attr.value = "value"; // 为属性节点添加属性值el.setAttributeNode(attr); // 将一个属性节点添加到el上el.setAttribute(name, value); // 设置el上的属性，若此属性不存在则添加el.getAttribute(name); // 获取el上的属性el.removeAttribute(name); // 删除el上的属性el.id; // 元素的id名el.className; // 元素的class名 获取元素的高宽123456789el.style.width / height; // 获取元素content的宽高，但是若未设置style会得到空，这个留待后面再说el.clientWidth / clientHeight; // 获取元素可视区的宽高，即为content+padding 元素相对于视窗可见部分的left和top，el.offsetWidth / offsetHeight; // 获取元素占位宽高，即为content+padding+border 相当于绝对定位的位置left和topel.scrollWidth / scrollHeight; // 与clientWidth类似，不过如果有滚轮会包括滚轮的宽度 // 滚轮的left和top// 注意，margin与以上都无关let W = document.body.clientWidth || window.innerWidth || document.documentElement.clientWidth; // 获取整个浏览器的可视区宽度，由于IE与firefox的实现有差异，所以需要兼容性写法 文档碎片化处理js 操作 dom 是一个很耗性能的过程，在某些情况下，不得不进行 dom 循环操作，我们每次对 dom 的操作都会触发”重排”，这严重影响到能耗，一般通常采取的做法是尽可能的减少 dom 操作来减少”重排”。面对循环操作 dom 的过程，我们选择使用文档碎片（creatDocumentFragment），将需要添加到 dom 中的内容都添加到文档碎片中，然后一次性的将文档碎片添加到 dom 树，这样就可以有效的减少操作 dom 的次数，减少重排的发生。 1234567891011121314&lt;ul id="list"&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function() &#123; var oFragment = document.createDocumentFragment(); var ul = document.getElementById("list"); var oLi = null; for (var i = 0; i &lt; 10; i++) &#123; oLi = document.createElement("li"); oLi.appendChild(document.createTextNode("item" + i)); oFragment.appendChild(oLi); &#125; ul.appendChild(oFragment); &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之非构造函数的继承]]></title>
    <url>%2F2017%2F06%2F01%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是”非构造函数”的继承？比如，现在有一个对象，叫做”中国人”。 123var Chinese = &#123; nation: "中国"&#125;; 还有一个对象，叫做”医生”。 123var Doctor = &#123; career: "医生"&#125;; 请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。 object()方法json 格式的发明人 Douglas Crockford，提出了一个 object()函数，可以做到这一点。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个 object()函数，其实只做一件事，就是把子对象的 prototype 属性，指向父对象，从而使得子对象与父对象连在一起。使用的时候，第一步先在父对象的基础上，生成子对象： 1var Doctor = object(Chinese); 然后，再加上子对象本身的属性： 1Doctor.career = "医生"; 这时，子对象已经继承了父对象的属性了。 1alert(Doctor.nation); //中国 深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。 123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === "object") &#123; c[i] = p[i].constructor === Array ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写： 1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性： 12Chinese.birthPlaces = ["北京", "上海", "香港"];Doctor.birthPlaces.push("厦门"); 这时，父对象就不会受到影响了。 12alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 目前，jQuery 库使用的就是这种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之构造函数的继承]]></title>
    <url>%2F2017%2F05%2F27%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言今天要介绍的是，对象之间的”继承”的五种方法。比如，现在有一个”动物”对象的构造函数。 123function Animal() &#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。 1234function Cat(name, color) &#123; this.name = name; this.color = color;&#125; 怎样才能使”猫”继承”动物”呢？ 构造函数绑定第一种方法也是最简单的方法，使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行： 1234567function Cat(name, color) &#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛", "黄色");alert(cat1.species); // 动物 prototype 模式第二种方法更常见，使用 prototype 属性。如果”猫”的 prototype 对象，指向一个 Animal 的实例，那么所有”猫”的实例，就能继承 Animal 了。 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛", "黄色");alert(cat1.species); // 动物 代码的第一行，我们将 Cat 的 prototype 对象指向一个 Animal 的实例。 1Cat.prototype = new Animal(); 它相当于完全删除了 prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？ 1Cat.prototype.constructor = Cat; 原来，任何一个 prototype 对象都有一个 constructor 属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor 是指向 Cat 的；加了这一行以后，Cat.prototype.constructor 指向 Animal。 1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个 constructor 属性，默认调用 prototype 对象的 constructor 属性。 1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor 也指向 Animal！ 1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1 明明是用构造函数 Cat 生成的），因此我们必须手动纠正，将 Cat.prototype 对象的 constructor 值改为 Cat。这就是第二行的意思。这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了 prototype 对象， 1o.prototype = &#123;&#125;; 那么，下一步必然是为新的 prototype 对象加上 constructor 属性，并将这个属性指回原来的构造函数。 1o.prototype.constructor = o; 直接继承 prototype第三种方法是对第二种方法的改进。由于 Animal 对象中，不变的属性都可以直接写入 Animal.prototype。所以，我们也可以让 Cat()跳过 Animal()，直接继承 Animal.prototype。现在，我们先将 Animal 对象改写： 12function Animal() &#123;&#125;Animal.prototype.species = "动物"; 然后，将 Cat 的 prototype 对象，然后指向 Animal 的 prototype 对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛", "黄色");alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立 Animal 的实例了），比较省内存。缺点是 Cat.prototype 和 Animal.prototype 现在指向了同一个对象，那么任何对 Cat.prototype 的修改，都会反映到 Animal.prototype。所以，上面这一段代码其实是有问题的。请看第二行 1Cat.prototype.constructor = Cat; 这一句实际上把 Animal.prototype 对象的 constructor 属性也改掉了！ 1alert(Animal.prototype.constructor); // Cat 利用空对象作为中介由于”直接继承 prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。 1234var F = function() &#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; F 是空对象，所以几乎不占内存。这时，修改 Cat 的 prototype 对象，就不会影响到 Animal 的 prototype 对象。 1alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。 1234567function extend(Child, Parent) &#123; var F = function() &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 使用的时候，方法如下 123extend(Cat, Animal);var cat1 = new Cat("大毛", "黄色");alert(cat1.species); // 动物 这个 extend 函数，就是 YUI 库如何实现继承的方法。另外，说明一点，函数体最后一行 1Child.uber = Parent.prototype; 意思是为子对象设一个 uber 属性，这个属性直接指向父对象的 prototype 属性。（uber 是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 拷贝继承上面是采用 prototype 对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。首先，还是把 Animal 的所有不变属性，都放到它的 prototype 对象上。 12function Animal() &#123;&#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。 12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的 prototype 对象中的属性，一一拷贝给 Child 对象的 prototype 对象。使用的时候，这样写： 123extend2(Cat, Animal);var cat1 = new Cat("大毛", "黄色");alert(cat1.species); // 动物 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之封装]]></title>
    <url>%2F2017%2F05%2F24%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Javascript 是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？ 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。 1234var Cat = &#123; name: "", color: ""&#125;; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。 123456var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 原始模式的改进我们可以写一个函数，解决代码重复的问题。 123456function Cat(name, color) &#123; return &#123; name: name, color: color &#125;;&#125; 然后生成实例对象，就等于是在调用函数： 12var cat1 = Cat("大毛", "黄色");var cat2 = Cat("二毛", "黑色"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 构造函数模式为了解决从原型对象生成实例的问题，Javascript 提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写: 1234function Cat(name, color) &#123; this.name = name; this.color = color;&#125; 我们现在就可以生成实例对象了。 1234var cat1 = new Cat("大毛", "黄色");var cat2 = new Cat("二毛", "黑色");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。 12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true Javascript 还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。 12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样： 12345678function Cat(name, color) &#123; this.name = name; this.color = color; this.type = "猫科动物"; this.eat = function() &#123; alert("吃老鼠"); &#125;;&#125; 还是采用同样的方法，生成实例： 1234var cat1 = new Cat("大毛", "黄色");var cat2 = new Cat("二毛", "黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。 1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。 Prototype 模式Javascript 规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。 12345678function Cat(name, color) &#123; this.name = name; this.color = color;&#125;Cat.prototype.type = "猫科动物";Cat.prototype.eat = function() &#123; alert("吃老鼠");&#125;; 然后，生成实例。 1234var cat1 = new Cat("大毛", "黄色");var cat2 = new Cat("二毛", "黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 1alert(cat1.eat == cat2.eat); //true Prototype 模式的验证方法为了配合prototype属性，Javascript 定义了一些辅助方法，帮助我们使用它。 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。 12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 12alert(cat1.hasOwnProperty("name")); // truealert(cat1.hasOwnProperty("type")); // false in 运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。 12alert("name" in cat1); // truealert("type" in cat1); // true in运算符还可以用来遍历某个对象的所有属性。 12345for(var prop in cat1)&#123; alert("cat1["+prop+"]="+cat1[prop]);&#125;`[_原文传送门_](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想]]></title>
    <url>%2F2017%2F05%2F22%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[jQuery 是目前使用最广泛的 javascript 函数库。 选择网页元素jQuery 的基本设计思想和主要用法，就是 “选择某个网页元素，然后对其进行某种操作”。这是它区别于其他 Javascript 库的根本特点。使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为\$），然后得到被选中的元素。 选择表达式可以是CSS 选择器： 1234$(document); //选择整个文档对象$("#myId"); //选择ID为myId的网页元素$("div.myClass"); // 选择class为myClass的div元素$("input[name=first]"); // 选择name属性等于first的input元素 也可以是 jQuery特有的表达式： 123456$("a:first"); //选择网页中第一个a元素$("tr:odd"); //选择表格的奇数行$("#myForm :input"); // 选择表单中的input元素$("div:visible"); //选择可见的div元素$("div:gt(2)"); // 选择所有的div元素，除了前三个$("div:animated"); // 选择当前处于动画状态的div元素 改变结果集jQuery 设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。 12345$("div").has("p"); // 选择包含p元素的div元素$("div").not(".myClass"); //选择class不等于myClass的div元素$("div").filter(".myClass"); //选择class等于myClass的div元素$("div").first(); //选择第1个div元素$("div").eq(5); //选择第6个div元素 有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery 也提供了在 DOM 树上的移动方法： 12345$("div").next("p"); //选择div元素后面的第一个p元素$("div").parent(); //选择div元素的父元素$("div").closest("form"); //选择离div最近的那个form父元素$("div").children(); //选择div的所有子元素$("div").siblings(); //选择div的同级元素 链式操作jQuery 设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如： 1234$("div") .find("h3") .eq(2) .html("Hello"); 分解开来，就是下面这样： 1234$("div") //找到div元素 .find("h3") //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html("Hello"); //将它的内容改为Hello 这是 jQuery 最令人称道、最方便的特点。它的原理在于每一步的 jQuery 操作，返回的都是一个 jQuery 对象，所以不同操作可以连在一起。jQuery 还提供了.end()方法，使得结果集可以后退一步： 1234567$("div") .find("h3") .eq(2) .html("Hello") .end() //退回到选中所有的h3元素的那一步 .eq(0) //选中第一个h3元素 .html("World"); //将它的内容改为World 元素的操作：取值和赋值操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。jQuery 设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即”取值器”与”赋值器”合一。到底是取值还是赋值，由函数的参数决定。 12$("h1").html(); //html()没有参数，表示取出h1的值$("h1").html("Hello"); //html()有参数Hello，表示对h1进行赋值 常见的取值和赋值函数如下： 123456.html() //取出或设置html内容.text() //取出或设置text内容.attr() //取出或设置HTML某个我们自定义DOM属性的值.prop() 取出或设置HTML某个本身固有属性的值.width() //取出或设置某个元素的宽度.height() //取出或设置某个元素的高度.val() //取出某个表单元素的值 需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的 text 内容）。 元素的操作：移动jQuery 设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。假定我们选中了一个 div 元素，需要把它移动到 p 元素后面。第一种方法是使用.insertAfter()，把 div 元素移动 p 元素后面： 1$("div").insertAfter($("p")); 第二种方法是使用.after()，把 p 元素加到 div 元素前面： 1$("p").after($("div")); 表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回 div 元素，第二种方法返回 p 元素。你可以根据需要，选择到底使用哪一种方法。使用这种模式的操作方法，一共有四对： 1234.insertAfter()和.after()：//在现存元素的外部，从后面插入元素.insertBefore()和.before()：//在现存元素的外部，从前面插入元素.appendTo()和.append()：//在现存元素的内部，从后面插入元素.prependTo()和.prepend()：//在现存元素的内部，从前面插入元素 元素的操作：复制、删除和创建除了元素的位置移动之外，jQuery 还提供其他几种操作元素的重要方法。复制元素使用.clone()。删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。清空元素内容（但是不删除该元素）使用.empty()。创建新元素的方法非常简单，只要把新元素直接传入 jQuery 的构造函数就行了： 123$("&lt;p&gt;Hello&lt;/p&gt;");$('&lt;li class="new"&gt;new list item&lt;/li&gt;');$("ul").append("&lt;li&gt;list item&lt;/li&gt;"); 工具方法jQuery 设计思想之六：除了对选中的元素进行操作以外，还提供一些与元素无关的工具方法（utility）。不必选中元素，就可以直接使用这些方法。如果你懂得 Javascript 语言的继承原理，那么就能理解工具方法的实质。它是定义在 jQuery 构造函数上的方法，即 jQuery.method()，所以可以直接使用。而那些操作元素的方法，是定义在构造函数的 prototype 对象上的方法，即 jQuery.prototype.method()，所以必须生成实例（即选中元素）后使用。如果不理解这种区别，问题也不大，只要把工具方法理解成，是像 javascript 原生函数那样，可以直接使用的方法就行了。常用的工具方法有以下几种： 123456789101112$.trim(); //去除字符串两端的空格。$.each(); //遍历一个数组或对象。$.inArray(); //返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。$.grep(); //返回数组中符合某种标准的元素。$.extend(); //将多个对象，合并到第一个对象。$.makeArray(); //将对象转化为数组。$.type(); //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。$.isArray(); //判断某个参数是否为数组。$.isEmptyObject(); //判断某个对象是否为空（不含有任何属性）。$.isFunction(); //判断某个参数是否为函数。$.isPlainObject(); //判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象。$.support(); //判断浏览器是否支持某个特性。 事件操作jQuery 设计思想之七，就是把事件直接绑定在网页元素之上。 123$("p").click(function() &#123; alert("Hello");&#125;); 目前，jQuery 主要支持以下事件： 1234567891011121314151617181920212223242526.blur() //表单元素失去焦点。.change() //表单元素的值发生变化.click() //鼠标单击.dblclick() //鼠标双击.focus() //表单元素获得焦点.focusin() //子元素获得焦点.focusout() //子元素失去焦点.hover() //同时为mouseenter和mouseleave事件指定处理函数.keydown() //按下键盘（长时间按键，只返回一个事件）.keypress() //按下键盘（长时间按键，将返回多个事件）.keyup() //松开键盘.load() //元素加载完毕.mousedown() //按下鼠标.mouseenter() //鼠标进入（进入子元素不触发）.mouseleave() //鼠标离开（离开子元素不触发）.mousemove() //鼠标在元素内部移动.mouseout() //鼠标离开（离开子元素也触发）.mouseover() //鼠标进入（进入子元素也触发）.mouseup()//松开鼠标.ready() //DOM加载完成.resize() //浏览器窗口的大小发生改变.scroll() //滚动条的位置发生变化.select() //用户选中文本框中的内容.submit() //用户递交表单.toggle() //根据鼠标点击的次数，依次运行多个函数.unload() //用户离开页面 以上这些事件在 jQuery 内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件，比如为多个事件绑定同一个函数： 123456$("input").bind( "click change", //同时绑定click和change事件 function() &#123; alert("Hello"); &#125;); 现在应该是使用 on 代替 bind 了。。有时，你只想让事件运行一次，这时可以使用.one()方法。 123$("p").one("click", function() &#123; alert("Hello"); //只运行一次，以后的点击不会运行&#125;); .unbind()用来解除事件绑定。 1$("p").unbind("click"); 所有的事件处理函数，都可以接受一个事件对象（event object）作为参数，比如下面例子中的 e： 123$("p").click(function(e) &#123; alert(e.type); // "click"&#125;); 这个事件对象有一些很有用的属性和方法： 12345678event.pageX; //事件发生时，鼠标距离网页左上角的水平距离event.pageY; //事件发生时，鼠标距离网页左上角的垂直距离event.type; //事件的类型（比如click）event.which; //按下了哪一个键event.data; //在事件对象上绑定数据，然后传入事件处理函数event.target; //事件针对的网页元素event.preventDefault(); //阻止事件的默认行为（比如点击链接，会自动打开新页面）event.stopPropagation(); //停止事件向上层元素冒泡 在事件处理函数中，可以用 this 关键字，返回事件针对的 DOM 元素： 1234567891011$("a").click(function(e) &#123; if ( $(this) .attr("href") .match("evil") ) &#123; //如果确认为有害链接 e.preventDefault(); //阻止打开 $(this).addClass("evil"); //加上表示有害的class &#125;&#125;); 有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。 12$("a").click();$("a").trigger("click"); 特殊效果最后，jQuery 允许对象呈现某些特殊效果。常用的特殊效果如下： 123456789.fadeIn() //淡入.fadeOut() //淡出.fadeTo() //调整透明度.hide() //隐藏元素.show() //显示元素.slideDown() //向下展开.slideUp() //向上卷起.slideToggle() //依次展开或卷起某个元素.toggle() //依次展示或隐藏某个元素 除了.show()和.hide()，所有其他特效的默认执行时间都是 400ms（毫秒），但是你可以改变这个设置。 12$("h1").fadeIn(300); // 300毫秒内淡入$("h1").fadeOut("slow"); // 缓慢地淡出 在特效结束后，可以指定执行某个函数。 123$("p").fadeOut(300, function() &#123; $(this).remove();&#125;); 更复杂的特效，可以用.animate()自定义。 12345678910$("div").animate( &#123; left: "+=50", //不断右移 opacity: 0.25 //指定透明度 &#125;, 300, // 持续时间 function() &#123; alert("done!"); &#125; //回调函数); .stop()和.delay()用来停止或延缓特效的执行。\$.fx.off 如果设置为 true，则关闭所有网页特效。原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的this用法]]></title>
    <url>%2F2017%2F05%2F21%2FJavaScript%E7%9A%84this%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如: 123function test() &#123; this.x = 1;&#125; 随着函数使用场合的不同，this 的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论 this 的用法。 纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此 this 就代表全局对象 Global。请看下面这段代码，它的运行结果是 1。 12345function test() &#123; this.x = 1; alert(this.x);&#125;test(); // 1 为了证明 this 就是全局对象，我对代码做一些改变： 12345var x = 1;function test() &#123; alert(this.x);&#125;test(); // 1 运行结果还是 1。再变一下： 123456var x = 1;function test() &#123; this.x = 0;&#125;test();alert(x); //0 作为对象方法的调用函数还可以作为某个对象的方法调用，这时 this 就指这个上级对象。 1234567function test() &#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this 就指这个新对象。 12345function test() &#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为 1。为了表明这时 this 不是全局对象，我对代码做一些改变： 123456var x = 2;function test() &#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为 2，表明全局变量 x 的值根本没变。 apply 调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指的就是这第一个参数。 12345678var x = 0;function test() &#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为 0，证明 this 指的是全局对象。如果把最后一行代码修改为 1o.m.apply(o); // 1 运行结果就变成了 1，证明了这时 this 代表的是对象 o。 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用缓存解决js递归调用性能问题]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3js%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述斐波那契序列通常是用来解释递归调用。 1234function fibonacci(n) &#123; if (n == 0 || n == 1) return n; return fibonacci(n - 1) + fibonacci(n - 2);&#125; 这个算法以教学为目的,但非常低效的,不仅因为递归,而且两次调用 fibonacci 函数,在函数里面右侧调用的 fibonacci(n-2) 在表达式左侧调用 fibonacci(n-1)时就已完全计算过一遍。 这个算法效率是如此之低,斐波纳契数超过 50 的实在太多了。你可以去喝杯咖啡或去睡午觉时等待答案。但如果你就用这个代码在 codewars 上很可能得到一个超时错误。 对于这个特定卡塔(类似打怪升级里面的级数)，我们想实现缓存的解决方案。这是特别酷的,因为它将让我们继续使用递归算法,同时仍然保持足够迅速的得到一个答案。 memoize 的版本的诀窍是,保持一个缓存数据结构(最有可能的关联数组),将斐波纳契数列的值缓存。当获取一个斐波那契数列值时,首先在缓存中查找，如果有则直接返回值,如果没有,再计算并把它放进缓存。 使用 memoize 的数据结构重构函数的递归 Fibonacci 以避免递归调用的缺陷。 分析斐波那契数列里面不断的递归调用自身，列入输入的是 70，那么需要计算 69 和 68 的值。在计算 69 的过程中又计算了 68、67、、、、、1。 计算 68 的过程又计算了 67、66、、、、、、、1 的值，如此重复计算的值太多了，花费的时间也就比较多。 缓存思想恰好可以减少不必要的重复计算。当第一遍计算 69 的值时就递归计算了 68、67、66、、、1 的值，之后的每次都先查看是否有缓存，有就直接返回缓存值，避免了重复计算。 代码123456789let cache = &#123;&#125;;let fibonacci = function(n) &#123; if (n == 0 || n == 1) return n; if (cache[n]) &#123; return cache[n]; &#125; return (cache[n] = fibonacci(n - 1) + fibonacci(n - 2));&#125;; 性能测试123456789101112131415161718192021222324252627//没有缓存时let tesetNum = 40;console.time("NoCache");function fibonacci1(n) &#123; if (n == 0 || n == 1) return n; return fibonacci1(n - 1) + fibonacci1(n - 2);&#125;fibonacci1(tesetNum);console.timeEnd("NoCache");// 使用缓存时console.time("HasCache");let cache = &#123;&#125;;let fibonacci = function(n) &#123; if (n == 0 || n == 1) return n; if (cache[n]) &#123; return cache[n]; &#125; return (cache[n] = fibonacci(n - 1) + fibonacci(n - 2));&#125;;fibonacci(tesetNum);console.timeEnd("HasCache");// 输出// NoCache: 1717.834ms// HasCache: 0.159ms 通过性能测试可以看到，当测试数是 40 时不适用缓存消耗的时间就是使用缓存的 1700 多倍(好可怕的数据)，我试了下当测试数据是 300 时，，，，，，，，我就等不急它的执行了。 使用场景当递归调用里有大量重复计算的情景，或者组件、数据等重复加载的情况下，使用缓存是个不错的选择(典型的以空间换时间)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组操作总结]]></title>
    <url>%2F2017%2F04%2F30%2FJavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组的创建数组的创建有两种方法，一种是通过字面量，另一种是通过 Array 构造函数。 字面量1var num1 = [1, 2, 3]; 值得注意的是，利用字面量创建数组时，不可在最后一个数组元素添加“,”，因为在老版本的浏览器中，会出现 bug。 Array 构造函数1var num2 = new Array(); //空数组 Array()可接收包含项作为参数，这时，会创建包含传入项的数组，如 num3。也可接收一个类型为 number 的数字作为参数，这时，会创建数组长度为该数字的数组，如 num5。 123var num3 = new Array("1", "2", "3"); //相当于["1","2","3"]var num4 = new Array(3); //length为3，元素均为undefined的数组var num5 = new Array(3).fill("1", 0, 2); //["1","1","1",undefined] 数组的转换关于数组的转换，这里只提数组转换成字符串的两种方法。分别是 toString()和 join()。 toString()该方法会返回数组各个项以逗号隔开的字符串。在使用 alert(array)方法打印数组时，会隐性调用 toString()方法。 123var num6 = [1, 2, 3];var num6Str = num6.toString(); //"1,2,3"alert(num6); //"1,2,3" join()join()只接收一个参数，该参数为数组中各项拼接的字符串，若不传参，默认为用“,”作为分隔符，效果相当于 toString()方法。 123var num7 = [1, 2, 3];num7.join("$"); //"1$2$3"num7.join(); //"1,2,3" 栈方法栈是一种先进先出的数据结构，而数组提供的 push()和 pop()方法类似栈的行为，所以叫栈方法。 push()push()方法可以接收多个参数，把它们依次添加至数组末尾，并返回修改后数组长度。 1234var num8 = [1, 2, 3];var num8Length = num8.push(4, 5);alert(num8); //1,2,3,4,5alert(num8Length); //5 pop()pop()方法是将数组的最后一项移除，并返回移除项。 12var num9 = [1, 2, 3];var last = num9.pop(); //3 队列方法shift()shift()方法是将数组的第一项移除，并返回移除项。 12var num10 = [1, 2, 3];var first = num10.shift(); //1 unshift()unshift()方法与 shift()方法用途相反，该方法可以接收多个参数，将参数依次加入数组的前端，并返回修改后数组的长度。 12var num11 = [1, 2, 3];var addArray = num11.unshift("-1", "0"); //5 重排序方法reverse()reverse()方法是使数组中的项进行反转，并返回经过排序后的数组。 12var num12 = [1, 2, 3];num12.reverse(); //[3,2,1] sort()sort()方法是默认为按照 ASCII 码进行顺序排序。在使用 sort()方法时，会先隐性调用 toString()方法将数组中的每一项进行字符串转化，实际上是进行字符串 ASCII 进行排序，并返回排序后的数组。 对于数组项中均为 number 类型的数据，我们可以在 sort()中传入一个比较函数，该比较函数接收两个参数，第一个参数为前一项，第二个参数为后一项。将两个参数进行对比，若 return 的值&gt;0,则将两个对比项进行调换位置，调换位置的项，再与较前的一项进行对比，依次类推，直到 return 值返回为 0 或者&lt;0 为止。 在比较函数中，return 值&gt;0，数组项调换位置；return 值&lt;0，数组项不调换位置；return 值=0，意味着两项相等，数组项不调换位置。 12345var num13 = [3, 2, 7, 14, 111, 0];num13.sort(function(value1, value2) &#123; return value1 - value2;&#125;);alert(num13); //0,2,3,7,14,111 操作方法concat()concat()方法是将数组与数组进行连结或者将数组项添加至数组末尾。 concat()会创建当前数组的一个副本，然后将接收到的参数依次添加到这个副本的末尾。如果没有传入参数，则返回的是当前数组的副本，相当于数组的复制；如果传入一个或多个数组参数，则会在副本的末尾依次添加数组参数中的每一个项；如果传入的是一个或多个非数组类型的数据，则这些值会依次被添加至副本的末尾。 注：可利用 concat()方法返回一个新数组的特性用于数组的复制。 12345var num14 = [1, 2, 3];var num15 = num14.concat([4, 5], [6, 7]);alert("参数为多个数组时：" + num15); //1,2,3,4,5,6,7var num16 = num14.concat(4, 5);alert("参数为非数组时：" + num16); //1,2,3,4,5 slice()slice()可以基于当前数组中的一个或多个项创建一个新的数组，并返回新的数组。 slice()可以接收一个或两个参数，即要返回项的起始位置和结束位置。当只有一个参数时，会返回从该参数指定的位置开始到数组的末尾位置；传入两个参数时，会返回从起始位置到结束位置前一项的数组项。 注：可利用 slice(0)方法返回一个新数组的特性用于数组的复制。 123var num17 = [1, 2, 3];num17.slice(1); //[2,3]num17.slice(1, 2); //[2] splice()splice()方法是比较强大的数组操作方法。因为可以利用该方法对数组进行删除，插入和替换操作。删除：splice(index,number)，只需要传入两个参数，index 为删除的第一项位置，number 为删除的项数。插入：splice(index,0,value1,value2,…)，需要至少传入三个参数，index 为从位置 index 处插入 value1,value2…。替换：splice(index,number,value1,value2…)，需要至少传入三个参数，index 为开始替换的位置，number 为替换的项数，value1，value2 等是替换的项。返回值：splice()方法返回的始终是一个数组，若有删除项，则返回含有所有被删除项的数组，若没有删除项，这返回空数组。 1234567var num18 = [1, 2, 3];//删除操作num18.splice(0, 2); //返回[1,2]，此时num18 = [3]//插入操作num18.splice(1, 0, 4, 5, 6); //返回[]，此时num18 =[3,4,5,6]//替换操作num18.splice(2, 2, 3, 3); //返回[5,6]，此时num18 = [3,4,3,3] 位置方法位置方法包含了两种方法，分别为 indexOf()和 lastIndexOf()，两个方法都接收两个参数，第一个参数为查找项，第二个参数（可选）为查找的起始位置，都返回查找项所出现的第一个位置，没有找到则返回-1。查找项和数组中的每一项进行比较时，使用使用的是全等操作符===，故需要值和数据类型一致。 indexOf()indexOf(value)该方法是从数组的开头开始查找值为 value 的项。indexOf(value,index)该方法是从下标为 index 的项开始查找值为 value 的项。 123var num19 = [1, 2, 3];num19.indexOf(1); //返回0num19.indexOf(3, 1); //返回2 lastIndexOf()lastIndexOf(value)该方法是从数组的末尾开始查找值为 value 的项。lastIndexOf(value,index)该方法是从数组末尾开始往前（从 0 开始）index 的项开始向数组开头查找值为 value 的项。 123var num20 = [1, 2, 3];num20.lastIndexOf(1); //返回0num20.lastIndexOf(1, 1); //返回0 迭代方法every()every(function(item,index,array){reutrn…;})对数组的每一项都传入给定函数，如该函数对每一项都返回 true，则返回 true，否则为 false。（类似且操作符） 1234567var num21 = [1, 2, 3];var every = num21.every(function(item, index, array) &#123; return item &gt; 0;&#125;); //truevar every1 = num21.every(function(item, index, array) &#123; return item &gt; 2;&#125;); //false some()some(function(item,index,array){return…})对数组的每一项都传入给定函数，如函数对某一项返回 true，则返回 true，否则为 false。（类似或操作符） 1234567var num22 = [1, 2, 3];var some = num21.some(function(item, index, array) &#123; return item &gt; 2;&#125;); //truevar some1 = num22.some(function(item, index, array) &#123; return item &gt; 6;&#125;); //false forEach()forEach(function(item,index,array){})对数组的每一项都传入给定函数，没有返回值。（类似 for 循环） 1234var num23 = [1, 2, 3];num23.forEach(function(item, index, array) &#123; console.log(item);&#125;); map()map(function(item,index,array){})对数组的每一项都传入给定函数，返回值为对数组操作后的数组。 1234var num24 = [1, 2, 3];num24.map(function(item, index, array) &#123; return item + 2;&#125;); //[3,4,5] filter()filter(function(item,index,array){})对数组的每一项都传入给定函数，返回值为给定函数返回为 true 的项组成的数组。 1234var num25 = [1, 2, 3];num25.filter(function(item, index, array) &#123; return item &gt; 2;&#125;); //[3] 归并方法归并方法有两个，分别为 reduce()和 reduceRight()。该两个方法接收两个参数，分别为给定函数和 pre 初始值（可选）。均迭代数组的每一项传入给定函数，并构造一个最终返回值。 reduce()reduce(function(pre,cur,index,array){return…})从第一项开始，迭代时，会将给定函数返回的值作为 pre 参数给到下一次迭代，直到最后。cur 指当前项，index 为当前项下标，array 为调用的数组。 123456789var num26 = [1, 2, 3];//只传给定函数num26.reduce(function(pre, cur, index, array) &#123; return pre + cur;&#125;); //6//传入给定函数和pre初始值num26.reduce(function(pre, cur, index, array) &#123; return pre + cur;&#125;, 4); //10 reduceRight()reduceRight()和 reduce()方法除了从数组的末尾还是开始开始遍历不同外，其他都一致。reduceRight()是从数组末尾开始遍历。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + hexo + next]]></title>
    <url>%2F2017%2F04%2F19%2FgithubPages%2F</url>
    <content type="text"><![CDATA[如何配置hexo + github page,请点击 Github Pages + Hexo 搭建博客如何搭建一个独立博客——简明Github Pages与Hexo教程Markdown语法教程使用hexo，如果换了电脑怎么更新博客？ let’s go!]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F02%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" #新建文件 More info: Writing Generate static files1$ hexo generate #生成静态页面至public目录 More info: Generating Run server1$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） More info: Server Deploy to remote sites1$ hexo deploy #将.deploy目录部署到GitHub More info: Deployment by my self1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo的简写形式1234hexo n "我的博客" == hexo new "我的博客"hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
  </entry>
</search>